#![allow(unknown_lints)]
#![allow(clippy::all)]

pub use crate::common::traits::{Convertable, EncodeError};
/// This file are autogenerated on build, everything you write here will be
/// replaced
use byte_formatter::{ByteDeserialize, ByteReader, ByteSerialize, ByteWriter, Error};
use serde::{Deserialize, Serialize};
use serde_json::Value;
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthLoginParamsObject {
    #[serde(rename = "deviceId")]
    pub device_id: Option<String>,
    #[serde(rename = "username")]
    pub username: String,
    #[serde(rename = "appId")]
    pub app_id: Option<i32>,
    #[serde(rename = "password")]
    pub password: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthLoginReturnsObject {
    #[serde(rename = "access_token")]
    pub access_token: String,
    #[serde(rename = "refresh_token")]
    pub refresh_token: String,
    #[serde(rename = "expires_in")]
    pub expires_in: i32,
    #[serde(rename = "userId")]
    pub user_id: String,
    #[serde(rename = "refresh_expires_in")]
    pub refresh_expires_in: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthLogin {
    Params(AuthAuthLoginParamsObject),
    Returns(AuthAuthLoginReturnsObject),
}
impl Convertable for AuthAuthLogin {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <AuthAuthLoginParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_login")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_login_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthLogin>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthLogin::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthSendRequestToResetPasswordParamsObject {
    #[serde(rename = "email")]
    pub email: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthSendRequestToResetPassword {
    Params(AuthAuthSendRequestToResetPasswordParamsObject),
    Returns(bool),
}
impl Convertable for AuthAuthSendRequestToResetPassword {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <AuthAuthSendRequestToResetPasswordParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_sendRequestToResetPassword")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_sendRequestToResetPassword_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthSendRequestToResetPassword>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthSendRequestToResetPassword::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthResetPasswordParamsObject {
    #[serde(rename = "hash")]
    pub hash: String,
    #[serde(rename = "newPassword")]
    pub new_password: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthResetPassword {
    Params(AuthAuthResetPasswordParamsObject),
    Returns(bool),
}
impl Convertable for AuthAuthResetPassword {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <AuthAuthResetPasswordParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_resetPassword")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_resetPassword_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthResetPassword>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthResetPassword::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthConfirmPasswordParamsObject {
    #[serde(rename = "password")]
    pub password: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthConfirmPassword {
    Params(AuthAuthConfirmPasswordParamsObject),
    Returns(bool),
}
impl Convertable for AuthAuthConfirmPassword {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <AuthAuthConfirmPasswordParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_confirmPassword")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_confirmPassword_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthConfirmPassword>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthConfirmPassword::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthCreateRequestToConfirmEmailParamsObject {
    #[serde(rename = "deviceId")]
    pub device_id: Option<String>,
    #[serde(rename = "referralCode")]
    pub referral_code: Option<String>,
    #[serde(rename = "email")]
    pub email: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthCreateRequestToConfirmEmail {
    Params(AuthAuthCreateRequestToConfirmEmailParamsObject),
    Returns(String),
}
impl Convertable for AuthAuthCreateRequestToConfirmEmail {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <AuthAuthCreateRequestToConfirmEmailParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_createRequestToConfirmEmail")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_createRequestToConfirmEmail_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthCreateRequestToConfirmEmail>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthCreateRequestToConfirmEmail::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthConfirmEmailByCodeParamsObject {
    #[serde(rename = "emailHash")]
    pub email_hash: String,
    #[serde(rename = "code")]
    pub code: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthConfirmEmailByCode {
    Params(AuthAuthConfirmEmailByCodeParamsObject),
    Returns(String),
}
impl Convertable for AuthAuthConfirmEmailByCode {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <AuthAuthConfirmEmailByCodeParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_confirmEmailByCode")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_confirmEmailByCode_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthConfirmEmailByCode>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthConfirmEmailByCode::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthDeleteEmailRequestParamsObject {
    #[serde(rename = "emailHash")]
    pub email_hash: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthDeleteEmailRequest {
    Params(AuthAuthDeleteEmailRequestParamsObject),
    Returns(bool),
}
impl Convertable for AuthAuthDeleteEmailRequest {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <AuthAuthDeleteEmailRequestParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_deleteEmailRequest")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_deleteEmailRequest_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthDeleteEmailRequest>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthDeleteEmailRequest::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthSetPasswordParamsObject {
    #[serde(rename = "password")]
    pub password: String,
    #[serde(rename = "providerId")]
    pub provider_id: Option<String>,
    #[serde(rename = "passwordHash")]
    pub password_hash: String,
    #[serde(rename = "appId")]
    pub app_id: Option<i32>,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthSetPasswordReturnsObject {
    #[serde(rename = "userId")]
    pub user_id: String,
    #[serde(rename = "refresh_expires_in")]
    pub refresh_expires_in: i32,
    #[serde(rename = "id_token")]
    pub id_token: String,
    #[serde(rename = "refresh_token")]
    pub refresh_token: String,
    #[serde(rename = "access_token")]
    pub access_token: String,
    #[serde(rename = "expires_in")]
    pub expires_in: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthSetPassword {
    Params(AuthAuthSetPasswordParamsObject),
    Returns(AuthAuthSetPasswordReturnsObject),
}
impl Convertable for AuthAuthSetPassword {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <AuthAuthSetPasswordParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_setPassword")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_setPassword_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthSetPassword>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthSetPassword::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthResentConfirmationMailParamsObject {
    #[serde(rename = "email")]
    pub email: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthResentConfirmationMail {
    Params(AuthAuthResentConfirmationMailParamsObject),
    Returns(bool),
}
impl Convertable for AuthAuthResentConfirmationMail {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <AuthAuthResentConfirmationMailParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_resentConfirmationMail")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_resentConfirmationMail_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthResentConfirmationMail>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthResentConfirmationMail::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthLogout {
    Params,
    Returns(bool),
}
impl Convertable for AuthAuthLogout {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_logout")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_logout_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthLogout>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthLogout::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthEmptyMethod {
    Params,
    Returns(bool),
}
impl Convertable for AuthAuthEmptyMethod {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_emptyMethod")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_emptyMethod_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthEmptyMethod>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthEmptyMethod::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct AuthAuthAssignProviderAccountToDeviceIdParamsObject {
    #[serde(rename = "token")]
    pub token: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthAuthAssignProviderAccountToDeviceId {
    Params(AuthAuthAssignProviderAccountToDeviceIdParamsObject),
    Returns(bool),
}
impl Convertable for AuthAuthAssignProviderAccountToDeviceId {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <AuthAuthAssignProviderAccountToDeviceIdParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("auth_auth_assignProviderAccountToDeviceId")
    }

    fn topic_to_response() -> String {
        String::from("auth_auth_assignProviderAccountToDeviceId_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<AuthAuthAssignProviderAccountToDeviceId>(json).map_err(EncodeError::Parse)?;
        if let AuthAuthAssignProviderAccountToDeviceId::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct BalancesBalancesGetSoftCurrencyBalanceReturnsObject {
    #[serde(rename = "balance")]
    pub balance: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BalancesBalancesGetSoftCurrencyBalance {
    Params,
    Returns(BalancesBalancesGetSoftCurrencyBalanceReturnsObject),
}
impl Convertable for BalancesBalancesGetSoftCurrencyBalance {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("balances_balances_getSoftCurrencyBalance")
    }

    fn topic_to_response() -> String {
        String::from("balances_balances_getSoftCurrencyBalance_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<BalancesBalancesGetSoftCurrencyBalance>(json).map_err(EncodeError::Parse)?;
        if let BalancesBalancesGetSoftCurrencyBalance::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct BalancesBalancesIncreaseSoftCurrencyParamsObject {
    #[serde(rename = "txId")]
    pub tx_id: String,
    #[serde(rename = "amount")]
    pub amount: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct BalancesBalancesIncreaseSoftCurrencyReturnsObject {
    #[serde(rename = "balance")]
    pub balance: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BalancesBalancesIncreaseSoftCurrency {
    Params(BalancesBalancesIncreaseSoftCurrencyParamsObject),
    Returns(BalancesBalancesIncreaseSoftCurrencyReturnsObject),
}
impl Convertable for BalancesBalancesIncreaseSoftCurrency {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <BalancesBalancesIncreaseSoftCurrencyParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("balances_balances_increaseSoftCurrency")
    }

    fn topic_to_response() -> String {
        String::from("balances_balances_increaseSoftCurrency_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<BalancesBalancesIncreaseSoftCurrency>(json).map_err(EncodeError::Parse)?;
        if let BalancesBalancesIncreaseSoftCurrency::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct BalancesBalancesDecreaseSoftCurrencyParamsObject {
    #[serde(rename = "txId")]
    pub tx_id: String,
    #[serde(rename = "amount")]
    pub amount: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct BalancesBalancesDecreaseSoftCurrencyReturnsObject {
    #[serde(rename = "balance")]
    pub balance: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BalancesBalancesDecreaseSoftCurrency {
    Params(BalancesBalancesDecreaseSoftCurrencyParamsObject),
    Returns(BalancesBalancesDecreaseSoftCurrencyReturnsObject),
}
impl Convertable for BalancesBalancesDecreaseSoftCurrency {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <BalancesBalancesDecreaseSoftCurrencyParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("balances_balances_decreaseSoftCurrency")
    }

    fn topic_to_response() -> String {
        String::from("balances_balances_decreaseSoftCurrency_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<BalancesBalancesDecreaseSoftCurrency>(json).map_err(EncodeError::Parse)?;
        if let BalancesBalancesDecreaseSoftCurrency::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct BalancesBalancesAddFreeExperienceParamsObject {
    #[serde(rename = "amount")]
    pub amount: i16,
    #[serde(rename = "txId")]
    pub tx_id: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct BalancesBalancesAddFreeExperienceReturnsObject {
    #[serde(rename = "balance")]
    pub balance: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BalancesBalancesAddFreeExperience {
    Params(BalancesBalancesAddFreeExperienceParamsObject),
    Returns(BalancesBalancesAddFreeExperienceReturnsObject),
}
impl Convertable for BalancesBalancesAddFreeExperience {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <BalancesBalancesAddFreeExperienceParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("balances_balances_addFreeExperience")
    }

    fn topic_to_response() -> String {
        String::from("balances_balances_addFreeExperience_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<BalancesBalancesAddFreeExperience>(json).map_err(EncodeError::Parse)?;
        if let BalancesBalancesAddFreeExperience::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct BalancesBalancesUseFreeExperienceParamsObject {
    #[serde(rename = "txId")]
    pub tx_id: String,
    #[serde(rename = "amount")]
    pub amount: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BalancesBalancesUseFreeExperience {
    Params(BalancesBalancesUseFreeExperienceParamsObject),
    Returns(bool),
}
impl Convertable for BalancesBalancesUseFreeExperience {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <BalancesBalancesUseFreeExperienceParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("balances_balances_useFreeExperience")
    }

    fn topic_to_response() -> String {
        String::from("balances_balances_useFreeExperience_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<BalancesBalancesUseFreeExperience>(json).map_err(EncodeError::Parse)?;
        if let BalancesBalancesUseFreeExperience::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct BalancesBalancesGetBalancesByUserIdReturnsObject {
    #[serde(rename = "freeExperience")]
    pub free_experience: i32,
    #[serde(rename = "softCurrency")]
    pub soft_currency: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BalancesBalancesGetBalancesByUserId {
    Params,
    Returns(BalancesBalancesGetBalancesByUserIdReturnsObject),
}
impl Convertable for BalancesBalancesGetBalancesByUserId {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("balances_balances_getBalancesByUserId")
    }

    fn topic_to_response() -> String {
        String::from("balances_balances_getBalancesByUserId_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<BalancesBalancesGetBalancesByUserId>(json).map_err(EncodeError::Parse)?;
        if let BalancesBalancesGetBalancesByUserId::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct BalancesBalancesGetFreeExperienceBalanceReturnsObject {
    #[serde(rename = "balance")]
    pub balance: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BalancesBalancesGetFreeExperienceBalance {
    Params,
    Returns(BalancesBalancesGetFreeExperienceBalanceReturnsObject),
}
impl Convertable for BalancesBalancesGetFreeExperienceBalance {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("balances_balances_getFreeExperienceBalance")
    }

    fn topic_to_response() -> String {
        String::from("balances_balances_getFreeExperienceBalance_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<BalancesBalancesGetFreeExperienceBalance>(json).map_err(EncodeError::Parse)?;
        if let BalancesBalancesGetFreeExperienceBalance::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct BalancesBalancesFreeExperienceAddedNotificationReturnsObject {
    #[serde(rename = "amount")]
    pub amount: i32,
    #[serde(rename = "balance")]
    pub balance: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BalancesBalancesFreeExperienceAddedNotification {
    Params,
    Returns(BalancesBalancesFreeExperienceAddedNotificationReturnsObject),
}
impl Convertable for BalancesBalancesFreeExperienceAddedNotification {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("balances_balances_freeExperienceAddedNotification")
    }

    fn topic_to_response() -> String {
        String::from("balances_balances_freeExperienceAddedNotification_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<BalancesBalancesFreeExperienceAddedNotification>(json).map_err(EncodeError::Parse)?;
        if let BalancesBalancesFreeExperienceAddedNotification::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GameBalancerGameBalancerStopSearching {
    Params,
    Returns(bool),
}
impl Convertable for GameBalancerGameBalancerStopSearching {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("gameBalancer_gameBalancer_stopSearching")
    }

    fn topic_to_response() -> String {
        String::from("gameBalancer_gameBalancer_stopSearching_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<GameBalancerGameBalancerStopSearching>(json).map_err(EncodeError::Parse)?;
        if let GameBalancerGameBalancerStopSearching::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct GameBalancerGameBalancerGameStartedNotificationReturnsObject {
    #[serde(rename = "roomStarted")]
    pub room_started: bool,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GameBalancerGameBalancerGameStartedNotification {
    Params,
    Returns(GameBalancerGameBalancerGameStartedNotificationReturnsObject),
}
impl Convertable for GameBalancerGameBalancerGameStartedNotification {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("gameBalancer_gameBalancer_gameStartedNotification")
    }

    fn topic_to_response() -> String {
        String::from("gameBalancer_gameBalancer_gameStartedNotification_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<GameBalancerGameBalancerGameStartedNotification>(json).map_err(EncodeError::Parse)?;
        if let GameBalancerGameBalancerGameStartedNotification::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct GameBalancerGameBalancerCheckInNotificationReturnsObject72 {
    #[serde(rename = "intelligence")]
    pub intelligence: String,
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: String,
    #[serde(rename = "skillPower")]
    pub skill_power: String,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: String,
    #[serde(rename = "ultPower")]
    pub ult_power: String,
    #[serde(rename = "strength")]
    pub strength: String,
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: String,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "attackDamage")]
    pub attack_damage: String,
    #[serde(rename = "agility")]
    pub agility: String,
    #[serde(rename = "health")]
    pub health: String,
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: String,
    #[serde(rename = "moveSpeed")]
    pub move_speed: String,
    #[serde(rename = "armor")]
    pub armor: String,
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct GameBalancerGameBalancerCheckInNotificationReturnsObject7 {
    #[serde(rename = "userId")]
    pub user_id: String,
    #[serde(rename = "nickname")]
    pub nickname: String,
    #[serde(rename = "attributes")]
    pub attributes: GameBalancerGameBalancerCheckInNotificationReturnsObject72,
    #[serde(rename = "heroId")]
    pub hero_id: i8,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct GameBalancerGameBalancerCheckInNotificationReturnsObject {
    #[serde(rename = "authToken")]
    pub auth_token: String,
    #[serde(rename = "roomUdpPort")]
    pub room_udp_port: i32,
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    #[serde(rename = "roomHost")]
    pub room_host: String,
    #[serde(rename = "roomId")]
    pub room_id: i32,
    #[serde(rename = "teamId")]
    pub team_id: i8,
    #[serde(rename = "success")]
    pub success: bool,
    #[serde(rename = "players")]
    pub players: Vec<GameBalancerGameBalancerCheckInNotificationReturnsObject7>,
    #[serde(rename = "roomTcpPort")]
    pub room_tcp_port: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GameBalancerGameBalancerCheckInNotification {
    Params,
    Returns(GameBalancerGameBalancerCheckInNotificationReturnsObject),
}
impl Convertable for GameBalancerGameBalancerCheckInNotification {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("gameBalancer_gameBalancer_checkInNotification")
    }

    fn topic_to_response() -> String {
        String::from("gameBalancer_gameBalancer_checkInNotification_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<GameBalancerGameBalancerCheckInNotification>(json).map_err(EncodeError::Parse)?;
        if let GameBalancerGameBalancerCheckInNotification::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsStatsUpdatedNotificationReturnsObject07 {
    #[serde(rename = "itemUid")]
    pub item_uid: Option<i32>,
    #[serde(rename = "equipment")]
    pub equipment: i8,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsStatsUpdatedNotificationReturnsObject011 {
    #[serde(rename = "attackDamage")]
    pub attack_damage: String,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: String,
    #[serde(rename = "armor")]
    pub armor: String,
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: String,
    #[serde(rename = "ultPower")]
    pub ult_power: String,
    #[serde(rename = "strength")]
    pub strength: String,
    #[serde(rename = "health")]
    pub health: String,
    #[serde(rename = "intelligence")]
    pub intelligence: String,
    #[serde(rename = "moveSpeed")]
    pub move_speed: String,
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: String,
    #[serde(rename = "agility")]
    pub agility: String,
    #[serde(rename = "skillPower")]
    pub skill_power: String,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: String,
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsStatsUpdatedNotificationReturnsObject015 {
    #[serde(rename = "agility")]
    pub agility: String,
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: String,
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: String,
    #[serde(rename = "skillPower")]
    pub skill_power: String,
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: String,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "health")]
    pub health: String,
    #[serde(rename = "moveSpeed")]
    pub move_speed: String,
    #[serde(rename = "attackDamage")]
    pub attack_damage: String,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: String,
    #[serde(rename = "armor")]
    pub armor: String,
    #[serde(rename = "ultPower")]
    pub ult_power: String,
    #[serde(rename = "strength")]
    pub strength: String,
    #[serde(rename = "intelligence")]
    pub intelligence: String,
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsStatsUpdatedNotificationReturnsObject0 {
    #[serde(rename = "experience")]
    pub experience: i32,
    #[serde(rename = "status")]
    pub status: i32,
    #[serde(rename = "level")]
    pub level: i16,
    #[serde(rename = "maxLevel")]
    pub max_level: i16,
    #[serde(rename = "blockId")]
    pub block_id: Option<String>,
    #[serde(rename = "toNextLevelScrolls")]
    pub to_next_level_scrolls: i32,
    #[serde(rename = "active")]
    pub active: bool,
    #[serde(rename = "slots")]
    pub slots: Vec<ListeriaStorageHeroesEndpointsStatsUpdatedNotificationReturnsObject07>,
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
    #[serde(rename = "linkToExplorer")]
    pub link_to_explorer: String,
    #[serde(rename = "isPending")]
    pub is_pending: bool,
    #[serde(rename = "attributes")]
    pub attributes: ListeriaStorageHeroesEndpointsStatsUpdatedNotificationReturnsObject011,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: Option<String>,
    #[serde(rename = "toNextLevelExperience")]
    pub to_next_level_experience: i32,
    #[serde(rename = "heroId")]
    pub hero_id: i8,
    #[serde(rename = "equipmentAttributes")]
    pub equipment_attributes: ListeriaStorageHeroesEndpointsStatsUpdatedNotificationReturnsObject015,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsStatsUpdatedNotificationReturnsObject {
    #[serde(rename = "hero")]
    pub hero: ListeriaStorageHeroesEndpointsStatsUpdatedNotificationReturnsObject0,
    #[serde(rename = "reason")]
    pub reason: i8,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageHeroesEndpointsStatsUpdatedNotification {
    Params,
    Returns(ListeriaStorageHeroesEndpointsStatsUpdatedNotificationReturnsObject),
}
impl Convertable for ListeriaStorageHeroesEndpointsStatsUpdatedNotification {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_heroesEndpoints_statsUpdatedNotification")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_heroesEndpoints_statsUpdatedNotification_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object =
            serde_json::from_value::<ListeriaStorageHeroesEndpointsStatsUpdatedNotification>(json).map_err(EncodeError::Parse)?;
        if let ListeriaStorageHeroesEndpointsStatsUpdatedNotification::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsGetHeroesListByUserIdReturnsObject8 {
    #[serde(rename = "itemUid")]
    pub item_uid: Option<i32>,
    #[serde(rename = "equipment")]
    pub equipment: i8,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsGetHeroesListByUserIdReturnsObject10 {
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: String,
    #[serde(rename = "attackDamage")]
    pub attack_damage: String,
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: String,
    #[serde(rename = "moveSpeed")]
    pub move_speed: String,
    #[serde(rename = "health")]
    pub health: String,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: String,
    #[serde(rename = "strength")]
    pub strength: String,
    #[serde(rename = "skillPower")]
    pub skill_power: String,
    #[serde(rename = "armor")]
    pub armor: String,
    #[serde(rename = "ultPower")]
    pub ult_power: String,
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: String,
    #[serde(rename = "intelligence")]
    pub intelligence: String,
    #[serde(rename = "agility")]
    pub agility: String,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsGetHeroesListByUserIdReturnsObject13 {
    #[serde(rename = "armor")]
    pub armor: String,
    #[serde(rename = "agility")]
    pub agility: String,
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: String,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "moveSpeed")]
    pub move_speed: String,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: String,
    #[serde(rename = "intelligence")]
    pub intelligence: String,
    #[serde(rename = "health")]
    pub health: String,
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: String,
    #[serde(rename = "strength")]
    pub strength: String,
    #[serde(rename = "attackDamage")]
    pub attack_damage: String,
    #[serde(rename = "ultPower")]
    pub ult_power: String,
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: String,
    #[serde(rename = "skillPower")]
    pub skill_power: String,
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsGetHeroesListByUserIdReturnsObject {
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: Option<String>,
    #[serde(rename = "toNextLevelExperience")]
    pub to_next_level_experience: i32,
    #[serde(rename = "maxLevel")]
    pub max_level: i16,
    #[serde(rename = "isPending")]
    pub is_pending: bool,
    #[serde(rename = "heroId")]
    pub hero_id: i8,
    #[serde(rename = "level")]
    pub level: i16,
    #[serde(rename = "toNextLevelScrolls")]
    pub to_next_level_scrolls: i32,
    #[serde(rename = "slots")]
    pub slots: Vec<ListeriaStorageHeroesEndpointsGetHeroesListByUserIdReturnsObject8>,
    #[serde(rename = "experience")]
    pub experience: i32,
    #[serde(rename = "attributes")]
    pub attributes: ListeriaStorageHeroesEndpointsGetHeroesListByUserIdReturnsObject10,
    #[serde(rename = "status")]
    pub status: i32,
    #[serde(rename = "linkToExplorer")]
    pub link_to_explorer: String,
    #[serde(rename = "equipmentAttributes")]
    pub equipment_attributes: ListeriaStorageHeroesEndpointsGetHeroesListByUserIdReturnsObject13,
    #[serde(rename = "blockId")]
    pub block_id: Option<String>,
    #[serde(rename = "active")]
    pub active: bool,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageHeroesEndpointsGetHeroesListByUserId {
    Params,
    Returns(Vec<ListeriaStorageHeroesEndpointsGetHeroesListByUserIdReturnsObject>),
}
impl Convertable for ListeriaStorageHeroesEndpointsGetHeroesListByUserId {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_heroesEndpoints_getHeroesListByUserId")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_heroesEndpoints_getHeroesListByUserId_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object =
            serde_json::from_value::<ListeriaStorageHeroesEndpointsGetHeroesListByUserId>(json).map_err(EncodeError::Parse)?;
        if let ListeriaStorageHeroesEndpointsGetHeroesListByUserId::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsGiveFreeExperienceToHeroParamsObject {
    #[serde(rename = "heroId")]
    pub hero_id: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero {
    Params(ListeriaStorageHeroesEndpointsGiveFreeExperienceToHeroParamsObject),
    Returns,
}
impl Convertable for ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <ListeriaStorageHeroesEndpointsGiveFreeExperienceToHeroParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_heroesEndpoints_giveFreeExperienceToHero")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_heroesEndpoints_giveFreeExperienceToHero_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        Ok(vec![])
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsHeroAddedNotificationReturnsObject10 {
    #[serde(rename = "itemUid")]
    pub item_uid: Option<i32>,
    #[serde(rename = "equipment")]
    pub equipment: i8,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsHeroAddedNotificationReturnsObject12 {
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: String,
    #[serde(rename = "intelligence")]
    pub intelligence: String,
    #[serde(rename = "strength")]
    pub strength: String,
    #[serde(rename = "armor")]
    pub armor: String,
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: String,
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: String,
    #[serde(rename = "ultPower")]
    pub ult_power: String,
    #[serde(rename = "health")]
    pub health: String,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "attackDamage")]
    pub attack_damage: String,
    #[serde(rename = "skillPower")]
    pub skill_power: String,
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: String,
    #[serde(rename = "agility")]
    pub agility: String,
    #[serde(rename = "moveSpeed")]
    pub move_speed: String,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsHeroAddedNotificationReturnsObject14 {
    #[serde(rename = "intelligence")]
    pub intelligence: String,
    #[serde(rename = "agility")]
    pub agility: String,
    #[serde(rename = "attackDamage")]
    pub attack_damage: String,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: String,
    #[serde(rename = "moveSpeed")]
    pub move_speed: String,
    #[serde(rename = "strength")]
    pub strength: String,
    #[serde(rename = "skillPower")]
    pub skill_power: String,
    #[serde(rename = "health")]
    pub health: String,
    #[serde(rename = "ultPower")]
    pub ult_power: String,
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: String,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: String,
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: String,
    #[serde(rename = "armor")]
    pub armor: String,
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsHeroAddedNotificationReturnsObject {
    #[serde(rename = "linkToExplorer")]
    pub link_to_explorer: String,
    #[serde(rename = "heroId")]
    pub hero_id: i8,
    #[serde(rename = "level")]
    pub level: i16,
    #[serde(rename = "isPending")]
    pub is_pending: bool,
    #[serde(rename = "toNextLevelExperience")]
    pub to_next_level_experience: i32,
    #[serde(rename = "maxLevel")]
    pub max_level: i16,
    #[serde(rename = "experience")]
    pub experience: i32,
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
    #[serde(rename = "active")]
    pub active: bool,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: Option<String>,
    #[serde(rename = "slots")]
    pub slots: Vec<ListeriaStorageHeroesEndpointsHeroAddedNotificationReturnsObject10>,
    #[serde(rename = "status")]
    pub status: i32,
    #[serde(rename = "attributes")]
    pub attributes: ListeriaStorageHeroesEndpointsHeroAddedNotificationReturnsObject12,
    #[serde(rename = "blockId")]
    pub block_id: Option<String>,
    #[serde(rename = "equipmentAttributes")]
    pub equipment_attributes: ListeriaStorageHeroesEndpointsHeroAddedNotificationReturnsObject14,
    #[serde(rename = "toNextLevelScrolls")]
    pub to_next_level_scrolls: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageHeroesEndpointsHeroAddedNotification {
    Params,
    Returns(ListeriaStorageHeroesEndpointsHeroAddedNotificationReturnsObject),
}
impl Convertable for ListeriaStorageHeroesEndpointsHeroAddedNotification {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_heroesEndpoints_heroAddedNotification")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_heroesEndpoints_heroAddedNotification_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object =
            serde_json::from_value::<ListeriaStorageHeroesEndpointsHeroAddedNotification>(json).map_err(EncodeError::Parse)?;
        if let ListeriaStorageHeroesEndpointsHeroAddedNotification::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageHeroesEndpointsLevelUpParamsObject {
    #[serde(rename = "heroId")]
    pub hero_id: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageHeroesEndpointsLevelUp {
    Params(ListeriaStorageHeroesEndpointsLevelUpParamsObject),
    Returns,
}
impl Convertable for ListeriaStorageHeroesEndpointsLevelUp {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <ListeriaStorageHeroesEndpointsLevelUpParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_heroesEndpoints_levelUp")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_heroesEndpoints_levelUp_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        Ok(vec![])
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageInventoryEndpointsGetLootboxesListReturnsObject0 {
    #[serde(rename = "status")]
    pub status: i32,
    #[serde(rename = "lootboxId")]
    pub lootbox_id: i32,
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageInventoryEndpointsGetLootboxesListReturnsObject {
    #[serde(rename = "lootboxes")]
    pub lootboxes: Vec<ListeriaStorageInventoryEndpointsGetLootboxesListReturnsObject0>,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageInventoryEndpointsGetLootboxesList {
    Params,
    Returns(ListeriaStorageInventoryEndpointsGetLootboxesListReturnsObject),
}
impl Convertable for ListeriaStorageInventoryEndpointsGetLootboxesList {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_inventoryEndpoints_getLootboxesList")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_inventoryEndpoints_getLootboxesList_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<ListeriaStorageInventoryEndpointsGetLootboxesList>(json).map_err(EncodeError::Parse)?;
        if let ListeriaStorageInventoryEndpointsGetLootboxesList::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageInventoryEndpointsOpenLootboxParamsObject {
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageInventoryEndpointsOpenLootbox {
    Params(ListeriaStorageInventoryEndpointsOpenLootboxParamsObject),
    Returns,
}
impl Convertable for ListeriaStorageInventoryEndpointsOpenLootbox {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <ListeriaStorageInventoryEndpointsOpenLootboxParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_inventoryEndpoints_openLootbox")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_inventoryEndpoints_openLootbox_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        Ok(vec![])
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageInventoryEndpointsGetItemsListReturnsObject9 {
    #[serde(rename = "power")]
    pub power: String,
    #[serde(rename = "statName")]
    pub stat_name: i8,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageInventoryEndpointsGetItemsListReturnsObject {
    #[serde(rename = "isPending")]
    pub is_pending: bool,
    #[serde(rename = "linkToExplorer")]
    pub link_to_explorer: String,
    #[serde(rename = "toNextLevelScrolls")]
    pub to_next_level_scrolls: i32,
    #[serde(rename = "maxLevel")]
    pub max_level: i16,
    #[serde(rename = "equipmentItemId")]
    pub equipment_item_id: i32,
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
    #[serde(rename = "status")]
    pub status: i32,
    #[serde(rename = "blockId")]
    pub block_id: Option<String>,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: Option<String>,
    #[serde(rename = "effects")]
    pub effects: Vec<ListeriaStorageInventoryEndpointsGetItemsListReturnsObject9>,
    #[serde(rename = "level")]
    pub level: i16,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageInventoryEndpointsGetItemsList {
    Params,
    Returns(Vec<ListeriaStorageInventoryEndpointsGetItemsListReturnsObject>),
}
impl Convertable for ListeriaStorageInventoryEndpointsGetItemsList {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_inventoryEndpoints_getItemsList")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_inventoryEndpoints_getItemsList_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<ListeriaStorageInventoryEndpointsGetItemsList>(json).map_err(EncodeError::Parse)?;
        if let ListeriaStorageInventoryEndpointsGetItemsList::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageInventoryEndpointsGetHeroScrollsCount {
    Params,
    Returns(i32),
}
impl Convertable for ListeriaStorageInventoryEndpointsGetHeroScrollsCount {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_inventoryEndpoints_getHeroScrollsCount")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_inventoryEndpoints_getHeroScrollsCount_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object =
            serde_json::from_value::<ListeriaStorageInventoryEndpointsGetHeroScrollsCount>(json).map_err(EncodeError::Parse)?;
        if let ListeriaStorageInventoryEndpointsGetHeroScrollsCount::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount {
    Params,
    Returns(i32),
}
impl Convertable for ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_inventoryEndpoints_getEquipmentScrollsCount")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_inventoryEndpoints_getEquipmentScrollsCount_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object =
            serde_json::from_value::<ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount>(json).map_err(EncodeError::Parse)?;
        if let ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageInventoryEndpointsAddedUnequippableItemNotificationReturnsObject {
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
    #[serde(rename = "itemId")]
    pub item_id: i32,
    #[serde(rename = "type")]
    pub rust_keyword_type: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification {
    Params,
    Returns(ListeriaStorageInventoryEndpointsAddedUnequippableItemNotificationReturnsObject),
}
impl Convertable for ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_inventoryEndpoints_addedUnequippableItemNotification")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_inventoryEndpoints_addedUnequippableItemNotification_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification>(json)
            .map_err(EncodeError::Parse)?;
        if let ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ListeriaStorageInventoryEndpointsLevelUpParamsObject {
    #[serde(rename = "itemId")]
    pub item_id: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListeriaStorageInventoryEndpointsLevelUp {
    Params(ListeriaStorageInventoryEndpointsLevelUpParamsObject),
    Returns,
}
impl Convertable for ListeriaStorageInventoryEndpointsLevelUp {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <ListeriaStorageInventoryEndpointsLevelUpParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("listeria-storage_inventoryEndpoints_levelUp")
    }

    fn topic_to_response() -> String {
        String::from("listeria-storage_inventoryEndpoints_levelUp_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        Ok(vec![])
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyEquipmentEndpointsEquipItemParamsObject {
    #[serde(rename = "slotId")]
    pub slot_id: i32,
    #[serde(rename = "heroId")]
    pub hero_id: i32,
    #[serde(rename = "itemId")]
    pub item_id: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyEquipmentEndpointsEquipItemReturnsObject {
    #[serde(rename = "slotId")]
    pub slot_id: i32,
    #[serde(rename = "itemId")]
    pub item_id: i32,
    #[serde(rename = "heroId")]
    pub hero_id: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyEquipmentEndpointsEquipItem {
    Params(LobbyEquipmentEndpointsEquipItemParamsObject),
    Returns(LobbyEquipmentEndpointsEquipItemReturnsObject),
}
impl Convertable for LobbyEquipmentEndpointsEquipItem {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <LobbyEquipmentEndpointsEquipItemParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_equipmentEndpoints_equipItem")
    }

    fn topic_to_response() -> String {
        String::from("lobby_equipmentEndpoints_equipItem_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyEquipmentEndpointsEquipItem>(json).map_err(EncodeError::Parse)?;
        if let LobbyEquipmentEndpointsEquipItem::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyEquipmentEndpointsUnequipItemParamsObject {
    #[serde(rename = "heroBindingId")]
    pub hero_binding_id: i32,
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyEquipmentEndpointsUnequipItemReturnsObject {
    #[serde(rename = "slotId")]
    pub slot_id: i32,
    #[serde(rename = "heroBindingId")]
    pub hero_binding_id: i32,
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyEquipmentEndpointsUnequipItem {
    Params(LobbyEquipmentEndpointsUnequipItemParamsObject),
    Returns(LobbyEquipmentEndpointsUnequipItemReturnsObject),
}
impl Convertable for LobbyEquipmentEndpointsUnequipItem {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <LobbyEquipmentEndpointsUnequipItemParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_equipmentEndpoints_unequipItem")
    }

    fn topic_to_response() -> String {
        String::from("lobby_equipmentEndpoints_unequipItem_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyEquipmentEndpointsUnequipItem>(json).map_err(EncodeError::Parse)?;
        if let LobbyEquipmentEndpointsUnequipItem::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyEquipmentEndpointsAddedItemNotificationReturnsObject3 {
    #[serde(rename = "statName")]
    pub stat_name: i8,
    #[serde(rename = "power")]
    pub power: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyEquipmentEndpointsAddedItemNotificationReturnsObject {
    #[serde(rename = "maxLevel")]
    pub max_level: i16,
    #[serde(rename = "toNextLevelScrolls")]
    pub to_next_level_scrolls: i32,
    #[serde(rename = "status")]
    pub status: i32,
    #[serde(rename = "effects")]
    pub effects: Vec<LobbyEquipmentEndpointsAddedItemNotificationReturnsObject3>,
    #[serde(rename = "level")]
    pub level: i16,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: Option<String>,
    #[serde(rename = "linkToExplorer")]
    pub link_to_explorer: String,
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
    #[serde(rename = "blockId")]
    pub block_id: Option<String>,
    #[serde(rename = "equipmentItemId")]
    pub equipment_item_id: i32,
    #[serde(rename = "isPending")]
    pub is_pending: bool,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyEquipmentEndpointsAddedItemNotification {
    Params,
    Returns(LobbyEquipmentEndpointsAddedItemNotificationReturnsObject),
}
impl Convertable for LobbyEquipmentEndpointsAddedItemNotification {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_equipmentEndpoints_addedItemNotification")
    }

    fn topic_to_response() -> String {
        String::from("lobby_equipmentEndpoints_addedItemNotification_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyEquipmentEndpointsAddedItemNotification>(json).map_err(EncodeError::Parse)?;
        if let LobbyEquipmentEndpointsAddedItemNotification::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyEquipmentEndpointsUpdatedItemNotificationReturnsObject0 {
    #[serde(rename = "power")]
    pub power: String,
    #[serde(rename = "statName")]
    pub stat_name: i8,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyEquipmentEndpointsUpdatedItemNotificationReturnsObject {
    #[serde(rename = "effects")]
    pub effects: Vec<LobbyEquipmentEndpointsUpdatedItemNotificationReturnsObject0>,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: Option<String>,
    #[serde(rename = "isPending")]
    pub is_pending: bool,
    #[serde(rename = "equipmentItemId")]
    pub equipment_item_id: i32,
    #[serde(rename = "linkToExplorer")]
    pub link_to_explorer: String,
    #[serde(rename = "maxLevel")]
    pub max_level: i16,
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
    #[serde(rename = "status")]
    pub status: i32,
    #[serde(rename = "toNextLevelScrolls")]
    pub to_next_level_scrolls: i32,
    #[serde(rename = "blockId")]
    pub block_id: Option<String>,
    #[serde(rename = "level")]
    pub level: i16,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyEquipmentEndpointsUpdatedItemNotification {
    Params,
    Returns(LobbyEquipmentEndpointsUpdatedItemNotificationReturnsObject),
}
impl Convertable for LobbyEquipmentEndpointsUpdatedItemNotification {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_equipmentEndpoints_updatedItemNotification")
    }

    fn topic_to_response() -> String {
        String::from("lobby_equipmentEndpoints_updatedItemNotification_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyEquipmentEndpointsUpdatedItemNotification>(json).map_err(EncodeError::Parse)?;
        if let LobbyEquipmentEndpointsUpdatedItemNotification::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyHeroesEndpointsEquipHeroParamsObject {
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyHeroesEndpointsEquipHero {
    Params(LobbyHeroesEndpointsEquipHeroParamsObject),
    Returns,
}
impl Convertable for LobbyHeroesEndpointsEquipHero {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <LobbyHeroesEndpointsEquipHeroParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_heroesEndpoints_equipHero")
    }

    fn topic_to_response() -> String {
        String::from("lobby_heroesEndpoints_equipHero_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        Ok(vec![])
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyHeroesEndpointsGetHeroesListReturnsObject0 {
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: Vec<String>,
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: Vec<String>,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "skillPower")]
    pub skill_power: Vec<String>,
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: Vec<String>,
    #[serde(rename = "armor")]
    pub armor: Vec<String>,
    #[serde(rename = "health")]
    pub health: Vec<String>,
    #[serde(rename = "intelligence")]
    pub intelligence: Vec<String>,
    #[serde(rename = "agility")]
    pub agility: Vec<String>,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: Vec<String>,
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: Vec<String>,
    #[serde(rename = "ultPower")]
    pub ult_power: Vec<String>,
    #[serde(rename = "strength")]
    pub strength: Vec<String>,
    #[serde(rename = "moveSpeed")]
    pub move_speed: Vec<String>,
    #[serde(rename = "attackDamage")]
    pub attack_damage: Vec<String>,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyHeroesEndpointsGetHeroesListReturnsObject {
    #[serde(rename = "statsRanges")]
    pub stats_ranges: LobbyHeroesEndpointsGetHeroesListReturnsObject0,
    #[serde(rename = "heroId")]
    pub hero_id: i8,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyHeroesEndpointsGetHeroesList {
    Params,
    Returns(Vec<LobbyHeroesEndpointsGetHeroesListReturnsObject>),
}
impl Convertable for LobbyHeroesEndpointsGetHeroesList {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_heroesEndpoints_getHeroesList")
    }

    fn topic_to_response() -> String {
        String::from("lobby_heroesEndpoints_getHeroesList_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyHeroesEndpointsGetHeroesList>(json).map_err(EncodeError::Parse)?;
        if let LobbyHeroesEndpointsGetHeroesList::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyHeroesEndpointsHeroAddedNotificationReturnsObject2 {
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: String,
    #[serde(rename = "moveSpeed")]
    pub move_speed: String,
    #[serde(rename = "armor")]
    pub armor: String,
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: String,
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: String,
    #[serde(rename = "intelligence")]
    pub intelligence: String,
    #[serde(rename = "agility")]
    pub agility: String,
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: String,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: String,
    #[serde(rename = "health")]
    pub health: String,
    #[serde(rename = "skillPower")]
    pub skill_power: String,
    #[serde(rename = "strength")]
    pub strength: String,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "ultPower")]
    pub ult_power: String,
    #[serde(rename = "attackDamage")]
    pub attack_damage: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyHeroesEndpointsHeroAddedNotificationReturnsObject3 {
    #[serde(rename = "itemUid")]
    pub item_uid: Option<i32>,
    #[serde(rename = "equipment")]
    pub equipment: i8,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyHeroesEndpointsHeroAddedNotificationReturnsObject9 {
    #[serde(rename = "armor")]
    pub armor: String,
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: String,
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: String,
    #[serde(rename = "ultPower")]
    pub ult_power: String,
    #[serde(rename = "skillPower")]
    pub skill_power: String,
    #[serde(rename = "intelligence")]
    pub intelligence: String,
    #[serde(rename = "attackDamage")]
    pub attack_damage: String,
    #[serde(rename = "health")]
    pub health: String,
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: String,
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: String,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "moveSpeed")]
    pub move_speed: String,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: String,
    #[serde(rename = "agility")]
    pub agility: String,
    #[serde(rename = "strength")]
    pub strength: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyHeroesEndpointsHeroAddedNotificationReturnsObject {
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
    #[serde(rename = "blockId")]
    pub block_id: Option<String>,
    #[serde(rename = "equipmentAttributes")]
    pub equipment_attributes: LobbyHeroesEndpointsHeroAddedNotificationReturnsObject2,
    #[serde(rename = "slots")]
    pub slots: Vec<LobbyHeroesEndpointsHeroAddedNotificationReturnsObject3>,
    #[serde(rename = "toNextLevelExperience")]
    pub to_next_level_experience: i32,
    #[serde(rename = "toNextLevelScrolls")]
    pub to_next_level_scrolls: i32,
    #[serde(rename = "active")]
    pub active: bool,
    #[serde(rename = "linkToExplorer")]
    pub link_to_explorer: String,
    #[serde(rename = "maxLevel")]
    pub max_level: i16,
    #[serde(rename = "attributes")]
    pub attributes: LobbyHeroesEndpointsHeroAddedNotificationReturnsObject9,
    #[serde(rename = "heroId")]
    pub hero_id: i8,
    #[serde(rename = "experience")]
    pub experience: i32,
    #[serde(rename = "isPending")]
    pub is_pending: bool,
    #[serde(rename = "status")]
    pub status: i32,
    #[serde(rename = "level")]
    pub level: i16,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: Option<String>,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyHeroesEndpointsHeroAddedNotification {
    Params,
    Returns(LobbyHeroesEndpointsHeroAddedNotificationReturnsObject),
}
impl Convertable for LobbyHeroesEndpointsHeroAddedNotification {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_heroesEndpoints_heroAddedNotification")
    }

    fn topic_to_response() -> String {
        String::from("lobby_heroesEndpoints_heroAddedNotification_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyHeroesEndpointsHeroAddedNotification>(json).map_err(EncodeError::Parse)?;
        if let LobbyHeroesEndpointsHeroAddedNotification::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyLobbyStartGame {
    Params,
    Returns,
}
impl Convertable for LobbyLobbyStartGame {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_lobby_startGame")
    }

    fn topic_to_response() -> String {
        String::from("lobby_lobby_startGame_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        Ok(vec![])
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyRegionsGetReturnsObject2 {
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "host")]
    pub host: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyRegionsGetReturnsObject {
    #[serde(rename = "isFixed")]
    pub is_fixed: bool,
    #[serde(rename = "active")]
    pub active: String,
    #[serde(rename = "list")]
    pub list: Vec<LobbyRegionsGetReturnsObject2>,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyRegionsGet {
    Params,
    Returns(LobbyRegionsGetReturnsObject),
}
impl Convertable for LobbyRegionsGet {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_regions_get")
    }

    fn topic_to_response() -> String {
        String::from("lobby_regions_get_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyRegionsGet>(json).map_err(EncodeError::Parse)?;
        if let LobbyRegionsGet::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyRegionsSetParamsObject {
    #[serde(rename = "isFixed")]
    pub is_fixed: bool,
    #[serde(rename = "regionName")]
    pub region_name: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyRegionsSet {
    Params(LobbyRegionsSetParamsObject),
    Returns,
}
impl Convertable for LobbyRegionsSet {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <LobbyRegionsSetParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_regions_set")
    }

    fn topic_to_response() -> String {
        String::from("lobby_regions_set_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        Ok(vec![])
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbySettingsGetReturnsObject {
    #[serde(rename = "language")]
    pub language: i8,
    #[serde(rename = "music")]
    pub music: bool,
    #[serde(rename = "quality")]
    pub quality: i8,
    #[serde(rename = "HFREffects")]
    pub hfr_effects: i8,
    #[serde(rename = "isChanged")]
    pub is_changed: bool,
    #[serde(rename = "sounds")]
    pub sounds: bool,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbySettingsGet {
    Params,
    Returns(LobbySettingsGetReturnsObject),
}
impl Convertable for LobbySettingsGet {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_settings_get")
    }

    fn topic_to_response() -> String {
        String::from("lobby_settings_get_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbySettingsGet>(json).map_err(EncodeError::Parse)?;
        if let LobbySettingsGet::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbySettingsSetParamsObject {
    #[serde(rename = "HFREffects")]
    pub hfr_effects: i8,
    #[serde(rename = "quality")]
    pub quality: i8,
    #[serde(rename = "sounds")]
    pub sounds: bool,
    #[serde(rename = "language")]
    pub language: i8,
    #[serde(rename = "music")]
    pub music: bool,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbySettingsSet {
    Params(LobbySettingsSetParamsObject),
    Returns,
}
impl Convertable for LobbySettingsSet {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <LobbySettingsSetParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_settings_set")
    }

    fn topic_to_response() -> String {
        String::from("lobby_settings_set_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        Ok(vec![])
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyStatsEndpointsGetLevelUpOptionsByPersonalTypeParamsObject {
    #[serde(rename = "personalType")]
    pub personal_type: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyStatsEndpointsGetLevelUpOptionsByPersonalTypeReturnsObject4 {
    #[serde(rename = "scrollsCount")]
    pub scrolls_count: i32,
    #[serde(rename = "level")]
    pub level: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyStatsEndpointsGetLevelUpOptionsByPersonalTypeReturnsObject7 {
    #[serde(rename = "coefficient")]
    pub coefficient: String,
    #[serde(rename = "level")]
    pub level: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyStatsEndpointsGetLevelUpOptionsByPersonalTypeReturnsObject {
    #[serde(rename = "agility")]
    pub agility: String,
    #[serde(rename = "intelligence")]
    pub intelligence: String,
    #[serde(rename = "experience")]
    pub experience: i32,
    #[serde(rename = "baseScrollsCount")]
    pub base_scrolls_count: i32,
    #[serde(rename = "scrollsByLevels")]
    pub scrolls_by_levels: Vec<LobbyStatsEndpointsGetLevelUpOptionsByPersonalTypeReturnsObject4>,
    #[serde(rename = "maxLevel")]
    pub max_level: i32,
    #[serde(rename = "baseExperience")]
    pub base_experience: i32,
    #[serde(rename = "experienceCoefficients")]
    pub experience_coefficients: Vec<LobbyStatsEndpointsGetLevelUpOptionsByPersonalTypeReturnsObject7>,
    #[serde(rename = "strength")]
    pub strength: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyStatsEndpointsGetLevelUpOptionsByPersonalType {
    Params(LobbyStatsEndpointsGetLevelUpOptionsByPersonalTypeParamsObject),
    Returns(LobbyStatsEndpointsGetLevelUpOptionsByPersonalTypeReturnsObject),
}
impl Convertable for LobbyStatsEndpointsGetLevelUpOptionsByPersonalType {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <LobbyStatsEndpointsGetLevelUpOptionsByPersonalTypeParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_statsEndpoints_getLevelUpOptionsByPersonalType")
    }

    fn topic_to_response() -> String {
        String::from("lobby_statsEndpoints_getLevelUpOptionsByPersonalType_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyStatsEndpointsGetLevelUpOptionsByPersonalType>(json).map_err(EncodeError::Parse)?;
        if let LobbyStatsEndpointsGetLevelUpOptionsByPersonalType::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyUserGetUserDataReturnsObject {
    #[serde(rename = "username")]
    pub username: String,
    #[serde(rename = "tokensIncreaseBy")]
    pub tokens_increase_by: String,
    #[serde(rename = "email")]
    pub email: String,
    #[serde(rename = "decreaseBy")]
    pub decrease_by: i8,
    #[serde(rename = "rating")]
    pub rating: i32,
    #[serde(rename = "increaseBy")]
    pub increase_by: i8,
    #[serde(rename = "draw")]
    pub draw: i8,
    #[serde(rename = "placeInLeaderBoard")]
    pub place_in_leader_board: i32,
    #[serde(rename = "image")]
    pub image: i8,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyUserGetUserData {
    Params,
    Returns(LobbyUserGetUserDataReturnsObject),
}
impl Convertable for LobbyUserGetUserData {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_user_getUserData")
    }

    fn topic_to_response() -> String {
        String::from("lobby_user_getUserData_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyUserGetUserData>(json).map_err(EncodeError::Parse)?;
        if let LobbyUserGetUserData::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyUserUpdateUsernameParamsObject {
    #[serde(rename = "newUsername")]
    pub new_username: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyUserUpdateUsernameReturnsObject {
    #[serde(rename = "newUsername")]
    pub new_username: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyUserUpdateUsername {
    Params(LobbyUserUpdateUsernameParamsObject),
    Returns(LobbyUserUpdateUsernameReturnsObject),
}
impl Convertable for LobbyUserUpdateUsername {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <LobbyUserUpdateUsernameParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_user_updateUsername")
    }

    fn topic_to_response() -> String {
        String::from("lobby_user_updateUsername_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyUserUpdateUsername>(json).map_err(EncodeError::Parse)?;
        if let LobbyUserUpdateUsername::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyUserGetLeaderBoardParamsObject {
    #[serde(rename = "page")]
    pub page: i16,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyUserGetLeaderBoardReturnsObject0 {
    #[serde(rename = "place")]
    pub place: i32,
    #[serde(rename = "rating")]
    pub rating: i32,
    #[serde(rename = "username")]
    pub username: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyUserGetLeaderBoardReturnsObject {
    #[serde(rename = "leaderboard")]
    pub leaderboard: Vec<LobbyUserGetLeaderBoardReturnsObject0>,
    #[serde(rename = "pages")]
    pub pages: i16,
    #[serde(rename = "page")]
    pub page: i16,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyUserGetLeaderBoard {
    Params(LobbyUserGetLeaderBoardParamsObject),
    Returns(LobbyUserGetLeaderBoardReturnsObject),
}
impl Convertable for LobbyUserGetLeaderBoard {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <LobbyUserGetLeaderBoardParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_user_getLeaderBoard")
    }

    fn topic_to_response() -> String {
        String::from("lobby_user_getLeaderBoard_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyUserGetLeaderBoard>(json).map_err(EncodeError::Parse)?;
        if let LobbyUserGetLeaderBoard::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyUserUpdateProfileImageParamsObject {
    #[serde(rename = "image")]
    pub image: i8,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct LobbyUserUpdateProfileImageReturnsObject {
    #[serde(rename = "imageId")]
    pub image_id: i8,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LobbyUserUpdateProfileImage {
    Params(LobbyUserUpdateProfileImageParamsObject),
    Returns(LobbyUserUpdateProfileImageReturnsObject),
}
impl Convertable for LobbyUserUpdateProfileImage {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <LobbyUserUpdateProfileImageParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("lobby_user_updateProfileImage")
    }

    fn topic_to_response() -> String {
        String::from("lobby_user_updateProfileImage_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<LobbyUserUpdateProfileImage>(json).map_err(EncodeError::Parse)?;
        if let LobbyUserUpdateProfileImage::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct MarketItemsGetLootboxesListReturnsObject0 {
    #[serde(rename = "type")]
    pub rust_keyword_type: i32,
    #[serde(rename = "currencyType")]
    pub currency_type: String,
    #[serde(rename = "id")]
    pub id: i32,
    #[serde(rename = "price")]
    pub price: String,
    #[serde(rename = "productType")]
    pub product_type: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct MarketItemsGetLootboxesListReturnsObject {
    #[serde(rename = "product")]
    pub product: Vec<MarketItemsGetLootboxesListReturnsObject0>,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MarketItemsGetLootboxesList {
    Params,
    Returns(MarketItemsGetLootboxesListReturnsObject),
}
impl Convertable for MarketItemsGetLootboxesList {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("market_items_getLootboxesList")
    }

    fn topic_to_response() -> String {
        String::from("market_items_getLootboxesList_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<MarketItemsGetLootboxesList>(json).map_err(EncodeError::Parse)?;
        if let MarketItemsGetLootboxesList::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ProductFactoryLootboxTypeGetByLootboxIdParamsObject {
    #[serde(rename = "lootboxId")]
    pub lootbox_id: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ProductFactoryLootboxTypeGetByLootboxIdReturnsObject {
    #[serde(rename = "id")]
    pub id: i32,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "lootboxId")]
    pub lootbox_id: String,
    #[serde(rename = "dropChanceMultiplier")]
    pub drop_chance_multiplier: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductFactoryLootboxTypeGetByLootboxId {
    Params(ProductFactoryLootboxTypeGetByLootboxIdParamsObject),
    Returns(ProductFactoryLootboxTypeGetByLootboxIdReturnsObject),
}
impl Convertable for ProductFactoryLootboxTypeGetByLootboxId {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <ProductFactoryLootboxTypeGetByLootboxIdParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("productFactory_lootboxType_getByLootboxId")
    }

    fn topic_to_response() -> String {
        String::from("productFactory_lootboxType_getByLootboxId_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<ProductFactoryLootboxTypeGetByLootboxId>(json).map_err(EncodeError::Parse)?;
        if let ProductFactoryLootboxTypeGetByLootboxId::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ProductFactoryProductLootboxOpenedNotificationReturnsObject0 {
    #[serde(rename = "amount")]
    pub amount: i32,
    #[serde(rename = "type")]
    pub rust_keyword_type: i32,
    #[serde(rename = "itemId")]
    pub item_id: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct ProductFactoryProductLootboxOpenedNotificationReturnsObject {
    #[serde(rename = "rewards")]
    pub rewards: Vec<ProductFactoryProductLootboxOpenedNotificationReturnsObject0>,
    #[serde(rename = "bindingId")]
    pub binding_id: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProductFactoryProductLootboxOpenedNotification {
    Params,
    Returns(ProductFactoryProductLootboxOpenedNotificationReturnsObject),
}
impl Convertable for ProductFactoryProductLootboxOpenedNotification {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("productFactory_product_lootboxOpenedNotification")
    }

    fn topic_to_response() -> String {
        String::from("productFactory_product_lootboxOpenedNotification_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<ProductFactoryProductLootboxOpenedNotification>(json).map_err(EncodeError::Parse)?;
        if let ProductFactoryProductLootboxOpenedNotification::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct PromoCodesUseCodeParamsObject {
    #[serde(rename = "code")]
    pub code: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct PromoCodesUseCodeReturnsObject {
    #[serde(rename = "currencyKey")]
    pub currency_key: String,
    #[serde(rename = "rewardType")]
    pub reward_type: String,
    #[serde(rename = "heroId")]
    pub hero_id: i8,
    #[serde(rename = "currencyAmount")]
    pub currency_amount: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PromoCodesUseCode {
    Params(PromoCodesUseCodeParamsObject),
    Returns(Vec<PromoCodesUseCodeReturnsObject>),
}
impl Convertable for PromoCodesUseCode {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <PromoCodesUseCodeParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("promo_codes_useCode")
    }

    fn topic_to_response() -> String {
        String::from("promo_codes_useCode_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<PromoCodesUseCode>(json).map_err(EncodeError::Parse)?;
        if let PromoCodesUseCode::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct PurchaseBalanceUserBalanceChangedNotificationReturnsObject {
    #[serde(rename = "amount")]
    pub amount: String,
    #[serde(rename = "blockId")]
    pub block_id: String,
    #[serde(rename = "currency")]
    pub currency: String,
    #[serde(rename = "balance")]
    pub balance: String,
    #[serde(rename = "transactionHash")]
    pub transaction_hash: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PurchaseBalanceUserBalanceChangedNotification {
    Params,
    Returns(PurchaseBalanceUserBalanceChangedNotificationReturnsObject),
}
impl Convertable for PurchaseBalanceUserBalanceChangedNotification {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("purchase_balance_userBalanceChangedNotification")
    }

    fn topic_to_response() -> String {
        String::from("purchase_balance_userBalanceChangedNotification_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<PurchaseBalanceUserBalanceChangedNotification>(json).map_err(EncodeError::Parse)?;
        if let PurchaseBalanceUserBalanceChangedNotification::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct PurchaseProductPurchaseLootboxParamsObject {
    #[serde(rename = "lootboxType")]
    pub lootbox_type: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PurchaseProductPurchaseLootbox {
    Params(PurchaseProductPurchaseLootboxParamsObject),
    Returns(bool),
}
impl Convertable for PurchaseProductPurchaseLootbox {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <PurchaseProductPurchaseLootboxParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("purchase_product_purchaseLootbox")
    }

    fn topic_to_response() -> String {
        String::from("purchase_product_purchaseLootbox_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<PurchaseProductPurchaseLootbox>(json).map_err(EncodeError::Parse)?;
        if let PurchaseProductPurchaseLootbox::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct PurchaseProductGetHeroListReturnsObject2 {
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: String,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "health")]
    pub health: i32,
    #[serde(rename = "skillPower")]
    pub skill_power: i32,
    #[serde(rename = "strength")]
    pub strength: i32,
    #[serde(rename = "attackDamage")]
    pub attack_damage: i32,
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: String,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: String,
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: i32,
    #[serde(rename = "ultPower")]
    pub ult_power: i32,
    #[serde(rename = "armor")]
    pub armor: String,
    #[serde(rename = "intelligence")]
    pub intelligence: i32,
    #[serde(rename = "moveSpeed")]
    pub move_speed: String,
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: i32,
    #[serde(rename = "agility")]
    pub agility: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct PurchaseProductGetHeroListReturnsObject {
    #[serde(rename = "heroId")]
    pub hero_id: i8,
    #[serde(rename = "price")]
    pub price: String,
    #[serde(rename = "stats")]
    pub stats: PurchaseProductGetHeroListReturnsObject2,
    #[serde(rename = "currency")]
    pub currency: String,
    #[serde(rename = "productType")]
    pub product_type: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PurchaseProductGetHeroList {
    Params,
    Returns(Vec<PurchaseProductGetHeroListReturnsObject>),
}
impl Convertable for PurchaseProductGetHeroList {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("purchase_product_getHeroList")
    }

    fn topic_to_response() -> String {
        String::from("purchase_product_getHeroList_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<PurchaseProductGetHeroList>(json).map_err(EncodeError::Parse)?;
        if let PurchaseProductGetHeroList::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct PurchaseProductGetEquipmentListReturnsObject3 {
    #[serde(rename = "ultEffectPower")]
    pub ult_effect_power: i32,
    #[serde(rename = "strength")]
    pub strength: i32,
    #[serde(rename = "skillPower")]
    pub skill_power: i32,
    #[serde(rename = "health")]
    pub health: i32,
    #[serde(rename = "attackDamage")]
    pub attack_damage: i32,
    #[serde(rename = "attackReloadSpeed")]
    pub attack_reload_speed: String,
    #[serde(rename = "mainCharacteristic")]
    pub main_characteristic: i8,
    #[serde(rename = "intelligence")]
    pub intelligence: i32,
    #[serde(rename = "healthRegenPercent")]
    pub health_regen_percent: String,
    #[serde(rename = "skillEffectPower")]
    pub skill_effect_power: i32,
    #[serde(rename = "moveSpeed")]
    pub move_speed: String,
    #[serde(rename = "ultPower")]
    pub ult_power: i32,
    #[serde(rename = "vampirismPower")]
    pub vampirism_power: String,
    #[serde(rename = "armor")]
    pub armor: String,
    #[serde(rename = "agility")]
    pub agility: i32,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct PurchaseProductGetEquipmentListReturnsObject {
    #[serde(rename = "price")]
    pub price: String,
    #[serde(rename = "currency")]
    pub currency: String,
    #[serde(rename = "productType")]
    pub product_type: String,
    #[serde(rename = "stats")]
    pub stats: PurchaseProductGetEquipmentListReturnsObject3,
    #[serde(rename = "equipmentId")]
    pub equipment_id: i32,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PurchaseProductGetEquipmentList {
    Params,
    Returns(Vec<PurchaseProductGetEquipmentListReturnsObject>),
}
impl Convertable for PurchaseProductGetEquipmentList {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("purchase_product_getEquipmentList")
    }

    fn topic_to_response() -> String {
        String::from("purchase_product_getEquipmentList_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<PurchaseProductGetEquipmentList>(json).map_err(EncodeError::Parse)?;
        if let PurchaseProductGetEquipmentList::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct PurchaseWalletGetByUserIdReturnsObject {
    #[serde(rename = "address")]
    pub address: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PurchaseWalletGetByUserId {
    Params,
    Returns(PurchaseWalletGetByUserIdReturnsObject),
}
impl Convertable for PurchaseWalletGetByUserId {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("purchase_wallet_getByUserId")
    }

    fn topic_to_response() -> String {
        String::from("purchase_wallet_getByUserId_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<PurchaseWalletGetByUserId>(json).map_err(EncodeError::Parse)?;
        if let PurchaseWalletGetByUserId::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct PurchaseWalletGetWalletByUserIdParamsObject {
    #[serde(rename = "userId")]
    pub user_id: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct PurchaseWalletGetWalletByUserIdReturnsObject {
    #[serde(rename = "address")]
    pub address: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PurchaseWalletGetWalletByUserId {
    Params(PurchaseWalletGetWalletByUserIdParamsObject),
    Returns(PurchaseWalletGetWalletByUserIdReturnsObject),
}
impl Convertable for PurchaseWalletGetWalletByUserId {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <PurchaseWalletGetWalletByUserIdParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("purchase_wallet_getWalletByUserId")
    }

    fn topic_to_response() -> String {
        String::from("purchase_wallet_getWalletByUserId_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<PurchaseWalletGetWalletByUserId>(json).map_err(EncodeError::Parse)?;
        if let PurchaseWalletGetWalletByUserId::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct TransactionsBalanceGetBalanceByUserIdParamsObject {
    #[serde(rename = "currency")]
    pub currency: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct TransactionsBalanceGetBalanceByUserIdReturnsObject {
    #[serde(rename = "amount")]
    pub amount: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransactionsBalanceGetBalanceByUserId {
    Params(TransactionsBalanceGetBalanceByUserIdParamsObject),
    Returns(TransactionsBalanceGetBalanceByUserIdReturnsObject),
}
impl Convertable for TransactionsBalanceGetBalanceByUserId {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <TransactionsBalanceGetBalanceByUserIdParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("transactions_balance_getBalanceByUserId")
    }

    fn topic_to_response() -> String {
        String::from("transactions_balance_getBalanceByUserId_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<TransactionsBalanceGetBalanceByUserId>(json).map_err(EncodeError::Parse)?;
        if let TransactionsBalanceGetBalanceByUserId::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct TransactionsBalanceGetBalancesByUserIdReturnsObject {
    #[serde(rename = "ETH")]
    pub eth: String,
    #[serde(rename = "LIS")]
    pub lis: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransactionsBalanceGetBalancesByUserId {
    Params,
    Returns(TransactionsBalanceGetBalancesByUserIdReturnsObject),
}
impl Convertable for TransactionsBalanceGetBalancesByUserId {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("transactions_balance_getBalancesByUserId")
    }

    fn topic_to_response() -> String {
        String::from("transactions_balance_getBalancesByUserId_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<TransactionsBalanceGetBalancesByUserId>(json).map_err(EncodeError::Parse)?;
        if let TransactionsBalanceGetBalancesByUserId::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct TransactionsBalanceGetBalancesByUserIdAsArrayReturnsObject {
    #[serde(rename = "currency")]
    pub currency: String,
    #[serde(rename = "amount")]
    pub amount: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransactionsBalanceGetBalancesByUserIdAsArray {
    Params,
    Returns(Vec<TransactionsBalanceGetBalancesByUserIdAsArrayReturnsObject>),
}
impl Convertable for TransactionsBalanceGetBalancesByUserIdAsArray {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("transactions_balance_getBalancesByUserIdAsArray")
    }

    fn topic_to_response() -> String {
        String::from("transactions_balance_getBalancesByUserIdAsArray_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<TransactionsBalanceGetBalancesByUserIdAsArray>(json).map_err(EncodeError::Parse)?;
        if let TransactionsBalanceGetBalancesByUserIdAsArray::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct TransactionsBalanceGetListWithPaginationParamsObject {
    #[serde(rename = "page")]
    pub page: i16,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct TransactionsBalanceGetListWithPaginationReturnsObject1 {
    #[serde(rename = "blockId")]
    pub block_id: String,
    #[serde(rename = "balanceChange")]
    pub balance_change: String,
    #[serde(rename = "dateTime")]
    pub date_time: String,
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct TransactionsBalanceGetListWithPaginationReturnsObject {
    #[serde(rename = "page")]
    pub page: i16,
    #[serde(rename = "list")]
    pub list: Vec<TransactionsBalanceGetListWithPaginationReturnsObject1>,
    #[serde(rename = "pages")]
    pub pages: i16,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransactionsBalanceGetListWithPagination {
    Params(TransactionsBalanceGetListWithPaginationParamsObject),
    Returns(TransactionsBalanceGetListWithPaginationReturnsObject),
}
impl Convertable for TransactionsBalanceGetListWithPagination {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <TransactionsBalanceGetListWithPaginationParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("transactions_balance_getListWithPagination")
    }

    fn topic_to_response() -> String {
        String::from("transactions_balance_getListWithPagination_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<TransactionsBalanceGetListWithPagination>(json).map_err(EncodeError::Parse)?;
        if let TransactionsBalanceGetListWithPagination::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct UserProfileGetMyProfileForBytesReturnsObject {
    #[serde(rename = "nickname")]
    pub nickname: String,
    #[serde(rename = "isNicknameChanged")]
    pub is_nickname_changed: bool,
    #[serde(rename = "verified")]
    pub verified: bool,
    #[serde(rename = "suspicious")]
    pub suspicious: bool,
    #[serde(rename = "email")]
    pub email: String,
    #[serde(rename = "isBanned")]
    pub is_banned: bool,
    #[serde(rename = "id")]
    pub id: i32,
    #[serde(rename = "isSubscribedToMailing")]
    pub is_subscribed_to_mailing: bool,
    #[serde(rename = "isDeleted")]
    pub is_deleted: bool,
    #[serde(rename = "isConfirmed")]
    pub is_confirmed: bool,
    #[serde(rename = "notice")]
    pub notice: String,
    #[serde(rename = "userId")]
    pub user_id: String,
    #[serde(rename = "reason")]
    pub reason: String,
    #[serde(rename = "registeredAt")]
    pub registered_at: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserProfileGetMyProfileForBytes {
    Params,
    Returns(UserProfileGetMyProfileForBytesReturnsObject),
}
impl Convertable for UserProfileGetMyProfileForBytes {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("user_profile_getMyProfileForBytes")
    }

    fn topic_to_response() -> String {
        String::from("user_profile_getMyProfileForBytes_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<UserProfileGetMyProfileForBytes>(json).map_err(EncodeError::Parse)?;
        if let UserProfileGetMyProfileForBytes::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct UserProfileGetTestDataReturnsObject {
    #[serde(rename = "hello")]
    pub hello: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UserProfileGetTestData {
    Params,
    Returns(UserProfileGetTestDataReturnsObject),
}
impl Convertable for UserProfileGetTestData {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = ();
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("user_profile_getTestData")
    }

    fn topic_to_response() -> String {
        String::from("user_profile_getTestData_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<UserProfileGetTestData>(json).map_err(EncodeError::Parse)?;
        if let UserProfileGetTestData::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize, ByteSerialize, ByteDeserialize)]
pub struct OrchestratorLootboxPurchaseParamsObject {
    #[serde(rename = "personalType")]
    pub personal_type: String,
}
#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OrchestratorLootboxPurchase {
    Params(OrchestratorLootboxPurchaseParamsObject),
    Returns(bool),
}
impl Convertable for OrchestratorLootboxPurchase {
    fn from_bytes_to_json(_byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        let params = <OrchestratorLootboxPurchaseParamsObject>::decode(_byte_reader)?;
        Ok(serde_json::to_value(params).unwrap())
    }

    fn topic_to_send() -> String {
        String::from("orchestrator_lootbox_purchase")
    }

    fn topic_to_response() -> String {
        String::from("orchestrator_lootbox_purchase_response")
    }

    fn from_value_to_bytes(json: Value) -> Result<Vec<u8>, EncodeError> {
        let object = serde_json::from_value::<OrchestratorLootboxPurchase>(json).map_err(EncodeError::Parse)?;
        if let OrchestratorLootboxPurchase::Returns(object) = object {
            let mut byte_writer = byte_formatter::ByteWriter::default();
            object.encode(&mut byte_writer).map_err(EncodeError::Byte)?;
            Ok(byte_writer.as_vec())
        } else {
            Ok(vec![])
        }
    }
}
pub enum AbstractSchema {
    AuthAuthLogin,
    AuthAuthSendRequestToResetPassword,
    AuthAuthResetPassword,
    AuthAuthConfirmPassword,
    AuthAuthCreateRequestToConfirmEmail,
    AuthAuthConfirmEmailByCode,
    AuthAuthDeleteEmailRequest,
    AuthAuthSetPassword,
    AuthAuthResentConfirmationMail,
    AuthAuthLogout,
    AuthAuthEmptyMethod,
    AuthAuthAssignProviderAccountToDeviceId,
    BalancesBalancesGetSoftCurrencyBalance,
    BalancesBalancesIncreaseSoftCurrency,
    BalancesBalancesDecreaseSoftCurrency,
    BalancesBalancesAddFreeExperience,
    BalancesBalancesUseFreeExperience,
    BalancesBalancesGetBalancesByUserId,
    BalancesBalancesGetFreeExperienceBalance,
    BalancesBalancesFreeExperienceAddedNotification,
    GameBalancerGameBalancerStopSearching,
    GameBalancerGameBalancerGameStartedNotification,
    GameBalancerGameBalancerCheckInNotification,
    ListeriaStorageHeroesEndpointsStatsUpdatedNotification,
    ListeriaStorageHeroesEndpointsGetHeroesListByUserId,
    ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero,
    ListeriaStorageHeroesEndpointsHeroAddedNotification,
    ListeriaStorageHeroesEndpointsLevelUp,
    ListeriaStorageInventoryEndpointsGetLootboxesList,
    ListeriaStorageInventoryEndpointsOpenLootbox,
    ListeriaStorageInventoryEndpointsGetItemsList,
    ListeriaStorageInventoryEndpointsGetHeroScrollsCount,
    ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount,
    ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification,
    ListeriaStorageInventoryEndpointsLevelUp,
    LobbyEquipmentEndpointsEquipItem,
    LobbyEquipmentEndpointsUnequipItem,
    LobbyEquipmentEndpointsAddedItemNotification,
    LobbyEquipmentEndpointsUpdatedItemNotification,
    LobbyHeroesEndpointsEquipHero,
    LobbyHeroesEndpointsGetHeroesList,
    LobbyHeroesEndpointsHeroAddedNotification,
    LobbyLobbyStartGame,
    LobbyRegionsGet,
    LobbyRegionsSet,
    LobbySettingsGet,
    LobbySettingsSet,
    LobbyStatsEndpointsGetLevelUpOptionsByPersonalType,
    LobbyUserGetUserData,
    LobbyUserUpdateUsername,
    LobbyUserGetLeaderBoard,
    LobbyUserUpdateProfileImage,
    MarketItemsGetLootboxesList,
    ProductFactoryLootboxTypeGetByLootboxId,
    ProductFactoryProductLootboxOpenedNotification,
    PromoCodesUseCode,
    PurchaseBalanceUserBalanceChangedNotification,
    PurchaseProductPurchaseLootbox,
    PurchaseProductGetHeroList,
    PurchaseProductGetEquipmentList,
    PurchaseWalletGetByUserId,
    PurchaseWalletGetWalletByUserId,
    TransactionsBalanceGetBalanceByUserId,
    TransactionsBalanceGetBalancesByUserId,
    TransactionsBalanceGetBalancesByUserIdAsArray,
    TransactionsBalanceGetListWithPagination,
    UserProfileGetMyProfileForBytes,
    UserProfileGetTestData,
    OrchestratorLootboxPurchase,
}
impl AbstractSchema {
    pub fn from_bytes(agent: u8, method: u8) -> Option<Self> {
        match (agent, method) {
            (2u8, 1u8) => Some(AbstractSchema::AuthAuthLogin),
            (2u8, 2u8) => Some(AbstractSchema::AuthAuthSendRequestToResetPassword),
            (2u8, 3u8) => Some(AbstractSchema::AuthAuthResetPassword),
            (2u8, 4u8) => Some(AbstractSchema::AuthAuthConfirmPassword),
            (2u8, 5u8) => Some(AbstractSchema::AuthAuthCreateRequestToConfirmEmail),
            (2u8, 6u8) => Some(AbstractSchema::AuthAuthConfirmEmailByCode),
            (2u8, 7u8) => Some(AbstractSchema::AuthAuthDeleteEmailRequest),
            (2u8, 8u8) => Some(AbstractSchema::AuthAuthSetPassword),
            (2u8, 9u8) => Some(AbstractSchema::AuthAuthResentConfirmationMail),
            (2u8, 10u8) => Some(AbstractSchema::AuthAuthLogout),
            (2u8, 11u8) => Some(AbstractSchema::AuthAuthEmptyMethod),
            (2u8, 12u8) => Some(AbstractSchema::AuthAuthAssignProviderAccountToDeviceId),
            (3u8, 13u8) => Some(AbstractSchema::BalancesBalancesGetSoftCurrencyBalance),
            (3u8, 14u8) => Some(AbstractSchema::BalancesBalancesIncreaseSoftCurrency),
            (3u8, 15u8) => Some(AbstractSchema::BalancesBalancesDecreaseSoftCurrency),
            (3u8, 16u8) => Some(AbstractSchema::BalancesBalancesAddFreeExperience),
            (3u8, 17u8) => Some(AbstractSchema::BalancesBalancesUseFreeExperience),
            (3u8, 18u8) => Some(AbstractSchema::BalancesBalancesGetBalancesByUserId),
            (3u8, 19u8) => Some(AbstractSchema::BalancesBalancesGetFreeExperienceBalance),
            (3u8, 20u8) => Some(AbstractSchema::BalancesBalancesFreeExperienceAddedNotification),
            (11u8, 21u8) => Some(AbstractSchema::GameBalancerGameBalancerStopSearching),
            (11u8, 22u8) => Some(AbstractSchema::GameBalancerGameBalancerGameStartedNotification),
            (11u8, 23u8) => Some(AbstractSchema::GameBalancerGameBalancerCheckInNotification),
            (13u8, 23u8) => Some(AbstractSchema::ListeriaStorageHeroesEndpointsStatsUpdatedNotification),
            (13u8, 24u8) => Some(AbstractSchema::ListeriaStorageHeroesEndpointsGetHeroesListByUserId),
            (13u8, 25u8) => Some(AbstractSchema::ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero),
            (13u8, 26u8) => Some(AbstractSchema::ListeriaStorageHeroesEndpointsHeroAddedNotification),
            (13u8, 27u8) => Some(AbstractSchema::ListeriaStorageHeroesEndpointsLevelUp),
            (13u8, 29u8) => Some(AbstractSchema::ListeriaStorageInventoryEndpointsGetLootboxesList),
            (13u8, 30u8) => Some(AbstractSchema::ListeriaStorageInventoryEndpointsOpenLootbox),
            (13u8, 31u8) => Some(AbstractSchema::ListeriaStorageInventoryEndpointsGetItemsList),
            (13u8, 32u8) => Some(AbstractSchema::ListeriaStorageInventoryEndpointsGetHeroScrollsCount),
            (13u8, 33u8) => Some(AbstractSchema::ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount),
            (13u8, 34u8) => Some(AbstractSchema::ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification),
            (13u8, 36u8) => Some(AbstractSchema::ListeriaStorageInventoryEndpointsLevelUp),
            (14u8, 37u8) => Some(AbstractSchema::LobbyEquipmentEndpointsEquipItem),
            (14u8, 38u8) => Some(AbstractSchema::LobbyEquipmentEndpointsUnequipItem),
            (14u8, 39u8) => Some(AbstractSchema::LobbyEquipmentEndpointsAddedItemNotification),
            (14u8, 40u8) => Some(AbstractSchema::LobbyEquipmentEndpointsUpdatedItemNotification),
            (14u8, 41u8) => Some(AbstractSchema::LobbyHeroesEndpointsEquipHero),
            (14u8, 42u8) => Some(AbstractSchema::LobbyHeroesEndpointsGetHeroesList),
            (14u8, 43u8) => Some(AbstractSchema::LobbyHeroesEndpointsHeroAddedNotification),
            (14u8, 44u8) => Some(AbstractSchema::LobbyLobbyStartGame),
            (14u8, 45u8) => Some(AbstractSchema::LobbyRegionsGet),
            (14u8, 46u8) => Some(AbstractSchema::LobbyRegionsSet),
            (14u8, 47u8) => Some(AbstractSchema::LobbySettingsGet),
            (14u8, 48u8) => Some(AbstractSchema::LobbySettingsSet),
            (14u8, 49u8) => Some(AbstractSchema::LobbyStatsEndpointsGetLevelUpOptionsByPersonalType),
            (14u8, 50u8) => Some(AbstractSchema::LobbyUserGetUserData),
            (14u8, 51u8) => Some(AbstractSchema::LobbyUserUpdateUsername),
            (14u8, 52u8) => Some(AbstractSchema::LobbyUserGetLeaderBoard),
            (14u8, 53u8) => Some(AbstractSchema::LobbyUserUpdateProfileImage),
            (15u8, 54u8) => Some(AbstractSchema::MarketItemsGetLootboxesList),
            (19u8, 55u8) => Some(AbstractSchema::ProductFactoryLootboxTypeGetByLootboxId),
            (19u8, 56u8) => Some(AbstractSchema::ProductFactoryProductLootboxOpenedNotification),
            (20u8, 57u8) => Some(AbstractSchema::PromoCodesUseCode),
            (21u8, 58u8) => Some(AbstractSchema::PurchaseBalanceUserBalanceChangedNotification),
            (21u8, 59u8) => Some(AbstractSchema::PurchaseProductPurchaseLootbox),
            (21u8, 60u8) => Some(AbstractSchema::PurchaseProductGetHeroList),
            (21u8, 61u8) => Some(AbstractSchema::PurchaseProductGetEquipmentList),
            (21u8, 62u8) => Some(AbstractSchema::PurchaseWalletGetByUserId),
            (21u8, 63u8) => Some(AbstractSchema::PurchaseWalletGetWalletByUserId),
            (27u8, 64u8) => Some(AbstractSchema::TransactionsBalanceGetBalanceByUserId),
            (27u8, 65u8) => Some(AbstractSchema::TransactionsBalanceGetBalancesByUserId),
            (27u8, 66u8) => Some(AbstractSchema::TransactionsBalanceGetBalancesByUserIdAsArray),
            (27u8, 67u8) => Some(AbstractSchema::TransactionsBalanceGetListWithPagination),
            (28u8, 68u8) => Some(AbstractSchema::UserProfileGetMyProfileForBytes),
            (28u8, 69u8) => Some(AbstractSchema::UserProfileGetTestData),
            (29u8, 55u8) => Some(AbstractSchema::OrchestratorLootboxPurchase),
            _ => None,
        }
    }

    pub fn from_string(agent: &str, method: &str) -> Option<Self> {
        match (agent, method) {
            ("auth", "auth_login") => Some(AbstractSchema::AuthAuthLogin),
            ("auth", "auth_sendRequestToResetPassword") => Some(AbstractSchema::AuthAuthSendRequestToResetPassword),
            ("auth", "auth_resetPassword") => Some(AbstractSchema::AuthAuthResetPassword),
            ("auth", "auth_confirmPassword") => Some(AbstractSchema::AuthAuthConfirmPassword),
            ("auth", "auth_createRequestToConfirmEmail") => Some(AbstractSchema::AuthAuthCreateRequestToConfirmEmail),
            ("auth", "auth_confirmEmailByCode") => Some(AbstractSchema::AuthAuthConfirmEmailByCode),
            ("auth", "auth_deleteEmailRequest") => Some(AbstractSchema::AuthAuthDeleteEmailRequest),
            ("auth", "auth_setPassword") => Some(AbstractSchema::AuthAuthSetPassword),
            ("auth", "auth_resentConfirmationMail") => Some(AbstractSchema::AuthAuthResentConfirmationMail),
            ("auth", "auth_logout") => Some(AbstractSchema::AuthAuthLogout),
            ("auth", "auth_emptyMethod") => Some(AbstractSchema::AuthAuthEmptyMethod),
            ("auth", "auth_assignProviderAccountToDeviceId") => Some(AbstractSchema::AuthAuthAssignProviderAccountToDeviceId),
            ("balances", "balances_getSoftCurrencyBalance") => Some(AbstractSchema::BalancesBalancesGetSoftCurrencyBalance),
            ("balances", "balances_increaseSoftCurrency") => Some(AbstractSchema::BalancesBalancesIncreaseSoftCurrency),
            ("balances", "balances_decreaseSoftCurrency") => Some(AbstractSchema::BalancesBalancesDecreaseSoftCurrency),
            ("balances", "balances_addFreeExperience") => Some(AbstractSchema::BalancesBalancesAddFreeExperience),
            ("balances", "balances_useFreeExperience") => Some(AbstractSchema::BalancesBalancesUseFreeExperience),
            ("balances", "balances_getBalancesByUserId") => Some(AbstractSchema::BalancesBalancesGetBalancesByUserId),
            ("balances", "balances_getFreeExperienceBalance") => Some(AbstractSchema::BalancesBalancesGetFreeExperienceBalance),
            ("balances", "balances_freeExperienceAddedNotification") => {
                Some(AbstractSchema::BalancesBalancesFreeExperienceAddedNotification)
            }
            ("gameBalancer", "gameBalancer_stopSearching") => Some(AbstractSchema::GameBalancerGameBalancerStopSearching),
            ("gameBalancer", "gameBalancer_gameStartedNotification") => {
                Some(AbstractSchema::GameBalancerGameBalancerGameStartedNotification)
            }
            ("gameBalancer", "gameBalancer_checkInNotification") => Some(AbstractSchema::GameBalancerGameBalancerCheckInNotification),
            ("listeria-storage", "heroesEndpoints_statsUpdatedNotification") => {
                Some(AbstractSchema::ListeriaStorageHeroesEndpointsStatsUpdatedNotification)
            }
            ("listeria-storage", "heroesEndpoints_getHeroesListByUserId") => {
                Some(AbstractSchema::ListeriaStorageHeroesEndpointsGetHeroesListByUserId)
            }
            ("listeria-storage", "heroesEndpoints_giveFreeExperienceToHero") => {
                Some(AbstractSchema::ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero)
            }
            ("listeria-storage", "heroesEndpoints_heroAddedNotification") => {
                Some(AbstractSchema::ListeriaStorageHeroesEndpointsHeroAddedNotification)
            }
            ("listeria-storage", "heroesEndpoints_levelUp") => Some(AbstractSchema::ListeriaStorageHeroesEndpointsLevelUp),
            ("listeria-storage", "inventoryEndpoints_getLootboxesList") => {
                Some(AbstractSchema::ListeriaStorageInventoryEndpointsGetLootboxesList)
            }
            ("listeria-storage", "inventoryEndpoints_openLootbox") => {
                Some(AbstractSchema::ListeriaStorageInventoryEndpointsOpenLootbox)
            }
            ("listeria-storage", "inventoryEndpoints_getItemsList") => {
                Some(AbstractSchema::ListeriaStorageInventoryEndpointsGetItemsList)
            }
            ("listeria-storage", "inventoryEndpoints_getHeroScrollsCount") => {
                Some(AbstractSchema::ListeriaStorageInventoryEndpointsGetHeroScrollsCount)
            }
            ("listeria-storage", "inventoryEndpoints_getEquipmentScrollsCount") => {
                Some(AbstractSchema::ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount)
            }
            ("listeria-storage", "inventoryEndpoints_addedUnequippableItemNotification") => {
                Some(AbstractSchema::ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification)
            }
            ("listeria-storage", "inventoryEndpoints_levelUp") => Some(AbstractSchema::ListeriaStorageInventoryEndpointsLevelUp),
            ("lobby", "equipmentEndpoints_equipItem") => Some(AbstractSchema::LobbyEquipmentEndpointsEquipItem),
            ("lobby", "equipmentEndpoints_unequipItem") => Some(AbstractSchema::LobbyEquipmentEndpointsUnequipItem),
            ("lobby", "equipmentEndpoints_addedItemNotification") => {
                Some(AbstractSchema::LobbyEquipmentEndpointsAddedItemNotification)
            }
            ("lobby", "equipmentEndpoints_updatedItemNotification") => {
                Some(AbstractSchema::LobbyEquipmentEndpointsUpdatedItemNotification)
            }
            ("lobby", "heroesEndpoints_equipHero") => Some(AbstractSchema::LobbyHeroesEndpointsEquipHero),
            ("lobby", "heroesEndpoints_getHeroesList") => Some(AbstractSchema::LobbyHeroesEndpointsGetHeroesList),
            ("lobby", "heroesEndpoints_heroAddedNotification") => Some(AbstractSchema::LobbyHeroesEndpointsHeroAddedNotification),
            ("lobby", "lobby_startGame") => Some(AbstractSchema::LobbyLobbyStartGame),
            ("lobby", "regions_get") => Some(AbstractSchema::LobbyRegionsGet),
            ("lobby", "regions_set") => Some(AbstractSchema::LobbyRegionsSet),
            ("lobby", "settings_get") => Some(AbstractSchema::LobbySettingsGet),
            ("lobby", "settings_set") => Some(AbstractSchema::LobbySettingsSet),
            ("lobby", "statsEndpoints_getLevelUpOptionsByPersonalType") => {
                Some(AbstractSchema::LobbyStatsEndpointsGetLevelUpOptionsByPersonalType)
            }
            ("lobby", "user_getUserData") => Some(AbstractSchema::LobbyUserGetUserData),
            ("lobby", "user_updateUsername") => Some(AbstractSchema::LobbyUserUpdateUsername),
            ("lobby", "user_getLeaderBoard") => Some(AbstractSchema::LobbyUserGetLeaderBoard),
            ("lobby", "user_updateProfileImage") => Some(AbstractSchema::LobbyUserUpdateProfileImage),
            ("market", "items_getLootboxesList") => Some(AbstractSchema::MarketItemsGetLootboxesList),
            ("productFactory", "lootboxType_getByLootboxId") => Some(AbstractSchema::ProductFactoryLootboxTypeGetByLootboxId),
            ("productFactory", "product_lootboxOpenedNotification") => {
                Some(AbstractSchema::ProductFactoryProductLootboxOpenedNotification)
            }
            ("promo", "codes_useCode") => Some(AbstractSchema::PromoCodesUseCode),
            ("purchase", "balance_userBalanceChangedNotification") => {
                Some(AbstractSchema::PurchaseBalanceUserBalanceChangedNotification)
            }
            ("purchase", "product_purchaseLootbox") => Some(AbstractSchema::PurchaseProductPurchaseLootbox),
            ("purchase", "product_getHeroList") => Some(AbstractSchema::PurchaseProductGetHeroList),
            ("purchase", "product_getEquipmentList") => Some(AbstractSchema::PurchaseProductGetEquipmentList),
            ("purchase", "wallet_getByUserId") => Some(AbstractSchema::PurchaseWalletGetByUserId),
            ("purchase", "wallet_getWalletByUserId") => Some(AbstractSchema::PurchaseWalletGetWalletByUserId),
            ("transactions", "balance_getBalanceByUserId") => Some(AbstractSchema::TransactionsBalanceGetBalanceByUserId),
            ("transactions", "balance_getBalancesByUserId") => Some(AbstractSchema::TransactionsBalanceGetBalancesByUserId),
            ("transactions", "balance_getBalancesByUserIdAsArray") => {
                Some(AbstractSchema::TransactionsBalanceGetBalancesByUserIdAsArray)
            }
            ("transactions", "balance_getListWithPagination") => Some(AbstractSchema::TransactionsBalanceGetListWithPagination),
            ("user", "profile_getMyProfileForBytes") => Some(AbstractSchema::UserProfileGetMyProfileForBytes),
            ("user", "profile_getTestData") => Some(AbstractSchema::UserProfileGetTestData),
            ("orchestrator", "lootbox_purchase") => Some(AbstractSchema::OrchestratorLootboxPurchase),
            _ => None,
        }
    }

    pub fn get_bytes_method(&self) -> (u8, u8) {
        match self {
            AbstractSchema::AuthAuthLogin => (2u8, 1u8),
            AbstractSchema::AuthAuthSendRequestToResetPassword => (2u8, 2u8),
            AbstractSchema::AuthAuthResetPassword => (2u8, 3u8),
            AbstractSchema::AuthAuthConfirmPassword => (2u8, 4u8),
            AbstractSchema::AuthAuthCreateRequestToConfirmEmail => (2u8, 5u8),
            AbstractSchema::AuthAuthConfirmEmailByCode => (2u8, 6u8),
            AbstractSchema::AuthAuthDeleteEmailRequest => (2u8, 7u8),
            AbstractSchema::AuthAuthSetPassword => (2u8, 8u8),
            AbstractSchema::AuthAuthResentConfirmationMail => (2u8, 9u8),
            AbstractSchema::AuthAuthLogout => (2u8, 10u8),
            AbstractSchema::AuthAuthEmptyMethod => (2u8, 11u8),
            AbstractSchema::AuthAuthAssignProviderAccountToDeviceId => (2u8, 12u8),
            AbstractSchema::BalancesBalancesGetSoftCurrencyBalance => (3u8, 13u8),
            AbstractSchema::BalancesBalancesIncreaseSoftCurrency => (3u8, 14u8),
            AbstractSchema::BalancesBalancesDecreaseSoftCurrency => (3u8, 15u8),
            AbstractSchema::BalancesBalancesAddFreeExperience => (3u8, 16u8),
            AbstractSchema::BalancesBalancesUseFreeExperience => (3u8, 17u8),
            AbstractSchema::BalancesBalancesGetBalancesByUserId => (3u8, 18u8),
            AbstractSchema::BalancesBalancesGetFreeExperienceBalance => (3u8, 19u8),
            AbstractSchema::BalancesBalancesFreeExperienceAddedNotification => (3u8, 20u8),
            AbstractSchema::GameBalancerGameBalancerStopSearching => (11u8, 21u8),
            AbstractSchema::GameBalancerGameBalancerGameStartedNotification => (11u8, 22u8),
            AbstractSchema::GameBalancerGameBalancerCheckInNotification => (11u8, 23u8),
            AbstractSchema::ListeriaStorageHeroesEndpointsStatsUpdatedNotification => (13u8, 23u8),
            AbstractSchema::ListeriaStorageHeroesEndpointsGetHeroesListByUserId => (13u8, 24u8),
            AbstractSchema::ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero => (13u8, 25u8),
            AbstractSchema::ListeriaStorageHeroesEndpointsHeroAddedNotification => (13u8, 26u8),
            AbstractSchema::ListeriaStorageHeroesEndpointsLevelUp => (13u8, 27u8),
            AbstractSchema::ListeriaStorageInventoryEndpointsGetLootboxesList => (13u8, 29u8),
            AbstractSchema::ListeriaStorageInventoryEndpointsOpenLootbox => (13u8, 30u8),
            AbstractSchema::ListeriaStorageInventoryEndpointsGetItemsList => (13u8, 31u8),
            AbstractSchema::ListeriaStorageInventoryEndpointsGetHeroScrollsCount => (13u8, 32u8),
            AbstractSchema::ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount => (13u8, 33u8),
            AbstractSchema::ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification => (13u8, 34u8),
            AbstractSchema::ListeriaStorageInventoryEndpointsLevelUp => (13u8, 36u8),
            AbstractSchema::LobbyEquipmentEndpointsEquipItem => (14u8, 37u8),
            AbstractSchema::LobbyEquipmentEndpointsUnequipItem => (14u8, 38u8),
            AbstractSchema::LobbyEquipmentEndpointsAddedItemNotification => (14u8, 39u8),
            AbstractSchema::LobbyEquipmentEndpointsUpdatedItemNotification => (14u8, 40u8),
            AbstractSchema::LobbyHeroesEndpointsEquipHero => (14u8, 41u8),
            AbstractSchema::LobbyHeroesEndpointsGetHeroesList => (14u8, 42u8),
            AbstractSchema::LobbyHeroesEndpointsHeroAddedNotification => (14u8, 43u8),
            AbstractSchema::LobbyLobbyStartGame => (14u8, 44u8),
            AbstractSchema::LobbyRegionsGet => (14u8, 45u8),
            AbstractSchema::LobbyRegionsSet => (14u8, 46u8),
            AbstractSchema::LobbySettingsGet => (14u8, 47u8),
            AbstractSchema::LobbySettingsSet => (14u8, 48u8),
            AbstractSchema::LobbyStatsEndpointsGetLevelUpOptionsByPersonalType => (14u8, 49u8),
            AbstractSchema::LobbyUserGetUserData => (14u8, 50u8),
            AbstractSchema::LobbyUserUpdateUsername => (14u8, 51u8),
            AbstractSchema::LobbyUserGetLeaderBoard => (14u8, 52u8),
            AbstractSchema::LobbyUserUpdateProfileImage => (14u8, 53u8),
            AbstractSchema::MarketItemsGetLootboxesList => (15u8, 54u8),
            AbstractSchema::ProductFactoryLootboxTypeGetByLootboxId => (19u8, 55u8),
            AbstractSchema::ProductFactoryProductLootboxOpenedNotification => (19u8, 56u8),
            AbstractSchema::PromoCodesUseCode => (20u8, 57u8),
            AbstractSchema::PurchaseBalanceUserBalanceChangedNotification => (21u8, 58u8),
            AbstractSchema::PurchaseProductPurchaseLootbox => (21u8, 59u8),
            AbstractSchema::PurchaseProductGetHeroList => (21u8, 60u8),
            AbstractSchema::PurchaseProductGetEquipmentList => (21u8, 61u8),
            AbstractSchema::PurchaseWalletGetByUserId => (21u8, 62u8),
            AbstractSchema::PurchaseWalletGetWalletByUserId => (21u8, 63u8),
            AbstractSchema::TransactionsBalanceGetBalanceByUserId => (27u8, 64u8),
            AbstractSchema::TransactionsBalanceGetBalancesByUserId => (27u8, 65u8),
            AbstractSchema::TransactionsBalanceGetBalancesByUserIdAsArray => (27u8, 66u8),
            AbstractSchema::TransactionsBalanceGetListWithPagination => (27u8, 67u8),
            AbstractSchema::UserProfileGetMyProfileForBytes => (28u8, 68u8),
            AbstractSchema::UserProfileGetTestData => (28u8, 69u8),
            AbstractSchema::OrchestratorLootboxPurchase => (29u8, 55u8),
        }
    }

    pub fn get_method(&self) -> (String, String) {
        match self {
            AbstractSchema::AuthAuthLogin => (String::from("auth"), String::from("auth_login")),
            AbstractSchema::AuthAuthSendRequestToResetPassword => {
                (String::from("auth"), String::from("auth_sendRequestToResetPassword"))
            }
            AbstractSchema::AuthAuthResetPassword => (String::from("auth"), String::from("auth_resetPassword")),
            AbstractSchema::AuthAuthConfirmPassword => (String::from("auth"), String::from("auth_confirmPassword")),
            AbstractSchema::AuthAuthCreateRequestToConfirmEmail => {
                (String::from("auth"), String::from("auth_createRequestToConfirmEmail"))
            }
            AbstractSchema::AuthAuthConfirmEmailByCode => (String::from("auth"), String::from("auth_confirmEmailByCode")),
            AbstractSchema::AuthAuthDeleteEmailRequest => (String::from("auth"), String::from("auth_deleteEmailRequest")),
            AbstractSchema::AuthAuthSetPassword => (String::from("auth"), String::from("auth_setPassword")),
            AbstractSchema::AuthAuthResentConfirmationMail => (String::from("auth"), String::from("auth_resentConfirmationMail")),
            AbstractSchema::AuthAuthLogout => (String::from("auth"), String::from("auth_logout")),
            AbstractSchema::AuthAuthEmptyMethod => (String::from("auth"), String::from("auth_emptyMethod")),
            AbstractSchema::AuthAuthAssignProviderAccountToDeviceId => {
                (String::from("auth"), String::from("auth_assignProviderAccountToDeviceId"))
            }
            AbstractSchema::BalancesBalancesGetSoftCurrencyBalance => {
                (String::from("balances"), String::from("balances_getSoftCurrencyBalance"))
            }
            AbstractSchema::BalancesBalancesIncreaseSoftCurrency => {
                (String::from("balances"), String::from("balances_increaseSoftCurrency"))
            }
            AbstractSchema::BalancesBalancesDecreaseSoftCurrency => {
                (String::from("balances"), String::from("balances_decreaseSoftCurrency"))
            }
            AbstractSchema::BalancesBalancesAddFreeExperience => {
                (String::from("balances"), String::from("balances_addFreeExperience"))
            }
            AbstractSchema::BalancesBalancesUseFreeExperience => {
                (String::from("balances"), String::from("balances_useFreeExperience"))
            }
            AbstractSchema::BalancesBalancesGetBalancesByUserId => {
                (String::from("balances"), String::from("balances_getBalancesByUserId"))
            }
            AbstractSchema::BalancesBalancesGetFreeExperienceBalance => {
                (String::from("balances"), String::from("balances_getFreeExperienceBalance"))
            }
            AbstractSchema::BalancesBalancesFreeExperienceAddedNotification => {
                (String::from("balances"), String::from("balances_freeExperienceAddedNotification"))
            }
            AbstractSchema::GameBalancerGameBalancerStopSearching => {
                (String::from("gameBalancer"), String::from("gameBalancer_stopSearching"))
            }
            AbstractSchema::GameBalancerGameBalancerGameStartedNotification => {
                (String::from("gameBalancer"), String::from("gameBalancer_gameStartedNotification"))
            }
            AbstractSchema::GameBalancerGameBalancerCheckInNotification => {
                (String::from("gameBalancer"), String::from("gameBalancer_checkInNotification"))
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsStatsUpdatedNotification => (
                String::from("listeria-storage"),
                String::from("heroesEndpoints_statsUpdatedNotification"),
            ),
            AbstractSchema::ListeriaStorageHeroesEndpointsGetHeroesListByUserId => (
                String::from("listeria-storage"),
                String::from("heroesEndpoints_getHeroesListByUserId"),
            ),
            AbstractSchema::ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero => (
                String::from("listeria-storage"),
                String::from("heroesEndpoints_giveFreeExperienceToHero"),
            ),
            AbstractSchema::ListeriaStorageHeroesEndpointsHeroAddedNotification => (
                String::from("listeria-storage"),
                String::from("heroesEndpoints_heroAddedNotification"),
            ),
            AbstractSchema::ListeriaStorageHeroesEndpointsLevelUp => {
                (String::from("listeria-storage"), String::from("heroesEndpoints_levelUp"))
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetLootboxesList => (
                String::from("listeria-storage"),
                String::from("inventoryEndpoints_getLootboxesList"),
            ),
            AbstractSchema::ListeriaStorageInventoryEndpointsOpenLootbox => {
                (String::from("listeria-storage"), String::from("inventoryEndpoints_openLootbox"))
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetItemsList => {
                (String::from("listeria-storage"), String::from("inventoryEndpoints_getItemsList"))
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetHeroScrollsCount => (
                String::from("listeria-storage"),
                String::from("inventoryEndpoints_getHeroScrollsCount"),
            ),
            AbstractSchema::ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount => (
                String::from("listeria-storage"),
                String::from("inventoryEndpoints_getEquipmentScrollsCount"),
            ),
            AbstractSchema::ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification => (
                String::from("listeria-storage"),
                String::from("inventoryEndpoints_addedUnequippableItemNotification"),
            ),
            AbstractSchema::ListeriaStorageInventoryEndpointsLevelUp => {
                (String::from("listeria-storage"), String::from("inventoryEndpoints_levelUp"))
            }
            AbstractSchema::LobbyEquipmentEndpointsEquipItem => (String::from("lobby"), String::from("equipmentEndpoints_equipItem")),
            AbstractSchema::LobbyEquipmentEndpointsUnequipItem => {
                (String::from("lobby"), String::from("equipmentEndpoints_unequipItem"))
            }
            AbstractSchema::LobbyEquipmentEndpointsAddedItemNotification => {
                (String::from("lobby"), String::from("equipmentEndpoints_addedItemNotification"))
            }
            AbstractSchema::LobbyEquipmentEndpointsUpdatedItemNotification => {
                (String::from("lobby"), String::from("equipmentEndpoints_updatedItemNotification"))
            }
            AbstractSchema::LobbyHeroesEndpointsEquipHero => (String::from("lobby"), String::from("heroesEndpoints_equipHero")),
            AbstractSchema::LobbyHeroesEndpointsGetHeroesList => {
                (String::from("lobby"), String::from("heroesEndpoints_getHeroesList"))
            }
            AbstractSchema::LobbyHeroesEndpointsHeroAddedNotification => {
                (String::from("lobby"), String::from("heroesEndpoints_heroAddedNotification"))
            }
            AbstractSchema::LobbyLobbyStartGame => (String::from("lobby"), String::from("lobby_startGame")),
            AbstractSchema::LobbyRegionsGet => (String::from("lobby"), String::from("regions_get")),
            AbstractSchema::LobbyRegionsSet => (String::from("lobby"), String::from("regions_set")),
            AbstractSchema::LobbySettingsGet => (String::from("lobby"), String::from("settings_get")),
            AbstractSchema::LobbySettingsSet => (String::from("lobby"), String::from("settings_set")),
            AbstractSchema::LobbyStatsEndpointsGetLevelUpOptionsByPersonalType => (
                String::from("lobby"),
                String::from("statsEndpoints_getLevelUpOptionsByPersonalType"),
            ),
            AbstractSchema::LobbyUserGetUserData => (String::from("lobby"), String::from("user_getUserData")),
            AbstractSchema::LobbyUserUpdateUsername => (String::from("lobby"), String::from("user_updateUsername")),
            AbstractSchema::LobbyUserGetLeaderBoard => (String::from("lobby"), String::from("user_getLeaderBoard")),
            AbstractSchema::LobbyUserUpdateProfileImage => (String::from("lobby"), String::from("user_updateProfileImage")),
            AbstractSchema::MarketItemsGetLootboxesList => (String::from("market"), String::from("items_getLootboxesList")),
            AbstractSchema::ProductFactoryLootboxTypeGetByLootboxId => {
                (String::from("productFactory"), String::from("lootboxType_getByLootboxId"))
            }
            AbstractSchema::ProductFactoryProductLootboxOpenedNotification => {
                (String::from("productFactory"), String::from("product_lootboxOpenedNotification"))
            }
            AbstractSchema::PromoCodesUseCode => (String::from("promo"), String::from("codes_useCode")),
            AbstractSchema::PurchaseBalanceUserBalanceChangedNotification => {
                (String::from("purchase"), String::from("balance_userBalanceChangedNotification"))
            }
            AbstractSchema::PurchaseProductPurchaseLootbox => (String::from("purchase"), String::from("product_purchaseLootbox")),
            AbstractSchema::PurchaseProductGetHeroList => (String::from("purchase"), String::from("product_getHeroList")),
            AbstractSchema::PurchaseProductGetEquipmentList => (String::from("purchase"), String::from("product_getEquipmentList")),
            AbstractSchema::PurchaseWalletGetByUserId => (String::from("purchase"), String::from("wallet_getByUserId")),
            AbstractSchema::PurchaseWalletGetWalletByUserId => (String::from("purchase"), String::from("wallet_getWalletByUserId")),
            AbstractSchema::TransactionsBalanceGetBalanceByUserId => {
                (String::from("transactions"), String::from("balance_getBalanceByUserId"))
            }
            AbstractSchema::TransactionsBalanceGetBalancesByUserId => {
                (String::from("transactions"), String::from("balance_getBalancesByUserId"))
            }
            AbstractSchema::TransactionsBalanceGetBalancesByUserIdAsArray => {
                (String::from("transactions"), String::from("balance_getBalancesByUserIdAsArray"))
            }
            AbstractSchema::TransactionsBalanceGetListWithPagination => {
                (String::from("transactions"), String::from("balance_getListWithPagination"))
            }
            AbstractSchema::UserProfileGetMyProfileForBytes => (String::from("user"), String::from("profile_getMyProfileForBytes")),
            AbstractSchema::UserProfileGetTestData => (String::from("user"), String::from("profile_getTestData")),
            AbstractSchema::OrchestratorLootboxPurchase => (String::from("orchestrator"), String::from("lootbox_purchase")),
        }
    }

    pub fn into_json(self, byte_reader: &mut ByteReader) -> Result<Value, byte_formatter::Error> {
        match self {
            AbstractSchema::AuthAuthLogin => AuthAuthLogin::from_bytes_to_json(byte_reader),
            AbstractSchema::AuthAuthSendRequestToResetPassword => AuthAuthSendRequestToResetPassword::from_bytes_to_json(byte_reader),
            AbstractSchema::AuthAuthResetPassword => AuthAuthResetPassword::from_bytes_to_json(byte_reader),
            AbstractSchema::AuthAuthConfirmPassword => AuthAuthConfirmPassword::from_bytes_to_json(byte_reader),
            AbstractSchema::AuthAuthCreateRequestToConfirmEmail => {
                AuthAuthCreateRequestToConfirmEmail::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::AuthAuthConfirmEmailByCode => AuthAuthConfirmEmailByCode::from_bytes_to_json(byte_reader),
            AbstractSchema::AuthAuthDeleteEmailRequest => AuthAuthDeleteEmailRequest::from_bytes_to_json(byte_reader),
            AbstractSchema::AuthAuthSetPassword => AuthAuthSetPassword::from_bytes_to_json(byte_reader),
            AbstractSchema::AuthAuthResentConfirmationMail => AuthAuthResentConfirmationMail::from_bytes_to_json(byte_reader),
            AbstractSchema::AuthAuthLogout => AuthAuthLogout::from_bytes_to_json(byte_reader),
            AbstractSchema::AuthAuthEmptyMethod => AuthAuthEmptyMethod::from_bytes_to_json(byte_reader),
            AbstractSchema::AuthAuthAssignProviderAccountToDeviceId => {
                AuthAuthAssignProviderAccountToDeviceId::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::BalancesBalancesGetSoftCurrencyBalance => {
                BalancesBalancesGetSoftCurrencyBalance::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::BalancesBalancesIncreaseSoftCurrency => {
                BalancesBalancesIncreaseSoftCurrency::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::BalancesBalancesDecreaseSoftCurrency => {
                BalancesBalancesDecreaseSoftCurrency::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::BalancesBalancesAddFreeExperience => BalancesBalancesAddFreeExperience::from_bytes_to_json(byte_reader),
            AbstractSchema::BalancesBalancesUseFreeExperience => BalancesBalancesUseFreeExperience::from_bytes_to_json(byte_reader),
            AbstractSchema::BalancesBalancesGetBalancesByUserId => {
                BalancesBalancesGetBalancesByUserId::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::BalancesBalancesGetFreeExperienceBalance => {
                BalancesBalancesGetFreeExperienceBalance::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::BalancesBalancesFreeExperienceAddedNotification => {
                BalancesBalancesFreeExperienceAddedNotification::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::GameBalancerGameBalancerStopSearching => {
                GameBalancerGameBalancerStopSearching::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::GameBalancerGameBalancerGameStartedNotification => {
                GameBalancerGameBalancerGameStartedNotification::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::GameBalancerGameBalancerCheckInNotification => {
                GameBalancerGameBalancerCheckInNotification::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsStatsUpdatedNotification => {
                ListeriaStorageHeroesEndpointsStatsUpdatedNotification::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsGetHeroesListByUserId => {
                ListeriaStorageHeroesEndpointsGetHeroesListByUserId::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero => {
                ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsHeroAddedNotification => {
                ListeriaStorageHeroesEndpointsHeroAddedNotification::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsLevelUp => {
                ListeriaStorageHeroesEndpointsLevelUp::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetLootboxesList => {
                ListeriaStorageInventoryEndpointsGetLootboxesList::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsOpenLootbox => {
                ListeriaStorageInventoryEndpointsOpenLootbox::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetItemsList => {
                ListeriaStorageInventoryEndpointsGetItemsList::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetHeroScrollsCount => {
                ListeriaStorageInventoryEndpointsGetHeroScrollsCount::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount => {
                ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification => {
                ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsLevelUp => {
                ListeriaStorageInventoryEndpointsLevelUp::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::LobbyEquipmentEndpointsEquipItem => LobbyEquipmentEndpointsEquipItem::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbyEquipmentEndpointsUnequipItem => LobbyEquipmentEndpointsUnequipItem::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbyEquipmentEndpointsAddedItemNotification => {
                LobbyEquipmentEndpointsAddedItemNotification::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::LobbyEquipmentEndpointsUpdatedItemNotification => {
                LobbyEquipmentEndpointsUpdatedItemNotification::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::LobbyHeroesEndpointsEquipHero => LobbyHeroesEndpointsEquipHero::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbyHeroesEndpointsGetHeroesList => LobbyHeroesEndpointsGetHeroesList::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbyHeroesEndpointsHeroAddedNotification => {
                LobbyHeroesEndpointsHeroAddedNotification::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::LobbyLobbyStartGame => LobbyLobbyStartGame::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbyRegionsGet => LobbyRegionsGet::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbyRegionsSet => LobbyRegionsSet::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbySettingsGet => LobbySettingsGet::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbySettingsSet => LobbySettingsSet::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbyStatsEndpointsGetLevelUpOptionsByPersonalType => {
                LobbyStatsEndpointsGetLevelUpOptionsByPersonalType::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::LobbyUserGetUserData => LobbyUserGetUserData::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbyUserUpdateUsername => LobbyUserUpdateUsername::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbyUserGetLeaderBoard => LobbyUserGetLeaderBoard::from_bytes_to_json(byte_reader),
            AbstractSchema::LobbyUserUpdateProfileImage => LobbyUserUpdateProfileImage::from_bytes_to_json(byte_reader),
            AbstractSchema::MarketItemsGetLootboxesList => MarketItemsGetLootboxesList::from_bytes_to_json(byte_reader),
            AbstractSchema::ProductFactoryLootboxTypeGetByLootboxId => {
                ProductFactoryLootboxTypeGetByLootboxId::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::ProductFactoryProductLootboxOpenedNotification => {
                ProductFactoryProductLootboxOpenedNotification::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::PromoCodesUseCode => PromoCodesUseCode::from_bytes_to_json(byte_reader),
            AbstractSchema::PurchaseBalanceUserBalanceChangedNotification => {
                PurchaseBalanceUserBalanceChangedNotification::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::PurchaseProductPurchaseLootbox => PurchaseProductPurchaseLootbox::from_bytes_to_json(byte_reader),
            AbstractSchema::PurchaseProductGetHeroList => PurchaseProductGetHeroList::from_bytes_to_json(byte_reader),
            AbstractSchema::PurchaseProductGetEquipmentList => PurchaseProductGetEquipmentList::from_bytes_to_json(byte_reader),
            AbstractSchema::PurchaseWalletGetByUserId => PurchaseWalletGetByUserId::from_bytes_to_json(byte_reader),
            AbstractSchema::PurchaseWalletGetWalletByUserId => PurchaseWalletGetWalletByUserId::from_bytes_to_json(byte_reader),
            AbstractSchema::TransactionsBalanceGetBalanceByUserId => {
                TransactionsBalanceGetBalanceByUserId::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::TransactionsBalanceGetBalancesByUserId => {
                TransactionsBalanceGetBalancesByUserId::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::TransactionsBalanceGetBalancesByUserIdAsArray => {
                TransactionsBalanceGetBalancesByUserIdAsArray::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::TransactionsBalanceGetListWithPagination => {
                TransactionsBalanceGetListWithPagination::from_bytes_to_json(byte_reader)
            }
            AbstractSchema::UserProfileGetMyProfileForBytes => UserProfileGetMyProfileForBytes::from_bytes_to_json(byte_reader),
            AbstractSchema::UserProfileGetTestData => UserProfileGetTestData::from_bytes_to_json(byte_reader),
            AbstractSchema::OrchestratorLootboxPurchase => OrchestratorLootboxPurchase::from_bytes_to_json(byte_reader),
        }
    }

    pub fn into_bytes(self, value: Value) -> Result<Vec<u8>, EncodeError> {
        match self {
            AbstractSchema::AuthAuthLogin => AuthAuthLogin::from_value_to_bytes(value),
            AbstractSchema::AuthAuthSendRequestToResetPassword => AuthAuthSendRequestToResetPassword::from_value_to_bytes(value),
            AbstractSchema::AuthAuthResetPassword => AuthAuthResetPassword::from_value_to_bytes(value),
            AbstractSchema::AuthAuthConfirmPassword => AuthAuthConfirmPassword::from_value_to_bytes(value),
            AbstractSchema::AuthAuthCreateRequestToConfirmEmail => AuthAuthCreateRequestToConfirmEmail::from_value_to_bytes(value),
            AbstractSchema::AuthAuthConfirmEmailByCode => AuthAuthConfirmEmailByCode::from_value_to_bytes(value),
            AbstractSchema::AuthAuthDeleteEmailRequest => AuthAuthDeleteEmailRequest::from_value_to_bytes(value),
            AbstractSchema::AuthAuthSetPassword => AuthAuthSetPassword::from_value_to_bytes(value),
            AbstractSchema::AuthAuthResentConfirmationMail => AuthAuthResentConfirmationMail::from_value_to_bytes(value),
            AbstractSchema::AuthAuthLogout => AuthAuthLogout::from_value_to_bytes(value),
            AbstractSchema::AuthAuthEmptyMethod => AuthAuthEmptyMethod::from_value_to_bytes(value),
            AbstractSchema::AuthAuthAssignProviderAccountToDeviceId => {
                AuthAuthAssignProviderAccountToDeviceId::from_value_to_bytes(value)
            }
            AbstractSchema::BalancesBalancesGetSoftCurrencyBalance => {
                BalancesBalancesGetSoftCurrencyBalance::from_value_to_bytes(value)
            }
            AbstractSchema::BalancesBalancesIncreaseSoftCurrency => BalancesBalancesIncreaseSoftCurrency::from_value_to_bytes(value),
            AbstractSchema::BalancesBalancesDecreaseSoftCurrency => BalancesBalancesDecreaseSoftCurrency::from_value_to_bytes(value),
            AbstractSchema::BalancesBalancesAddFreeExperience => BalancesBalancesAddFreeExperience::from_value_to_bytes(value),
            AbstractSchema::BalancesBalancesUseFreeExperience => BalancesBalancesUseFreeExperience::from_value_to_bytes(value),
            AbstractSchema::BalancesBalancesGetBalancesByUserId => BalancesBalancesGetBalancesByUserId::from_value_to_bytes(value),
            AbstractSchema::BalancesBalancesGetFreeExperienceBalance => {
                BalancesBalancesGetFreeExperienceBalance::from_value_to_bytes(value)
            }
            AbstractSchema::BalancesBalancesFreeExperienceAddedNotification => {
                BalancesBalancesFreeExperienceAddedNotification::from_value_to_bytes(value)
            }
            AbstractSchema::GameBalancerGameBalancerStopSearching => GameBalancerGameBalancerStopSearching::from_value_to_bytes(value),
            AbstractSchema::GameBalancerGameBalancerGameStartedNotification => {
                GameBalancerGameBalancerGameStartedNotification::from_value_to_bytes(value)
            }
            AbstractSchema::GameBalancerGameBalancerCheckInNotification => {
                GameBalancerGameBalancerCheckInNotification::from_value_to_bytes(value)
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsStatsUpdatedNotification => {
                ListeriaStorageHeroesEndpointsStatsUpdatedNotification::from_value_to_bytes(value)
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsGetHeroesListByUserId => {
                ListeriaStorageHeroesEndpointsGetHeroesListByUserId::from_value_to_bytes(value)
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero => {
                ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero::from_value_to_bytes(value)
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsHeroAddedNotification => {
                ListeriaStorageHeroesEndpointsHeroAddedNotification::from_value_to_bytes(value)
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsLevelUp => ListeriaStorageHeroesEndpointsLevelUp::from_value_to_bytes(value),
            AbstractSchema::ListeriaStorageInventoryEndpointsGetLootboxesList => {
                ListeriaStorageInventoryEndpointsGetLootboxesList::from_value_to_bytes(value)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsOpenLootbox => {
                ListeriaStorageInventoryEndpointsOpenLootbox::from_value_to_bytes(value)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetItemsList => {
                ListeriaStorageInventoryEndpointsGetItemsList::from_value_to_bytes(value)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetHeroScrollsCount => {
                ListeriaStorageInventoryEndpointsGetHeroScrollsCount::from_value_to_bytes(value)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount => {
                ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount::from_value_to_bytes(value)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification => {
                ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification::from_value_to_bytes(value)
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsLevelUp => {
                ListeriaStorageInventoryEndpointsLevelUp::from_value_to_bytes(value)
            }
            AbstractSchema::LobbyEquipmentEndpointsEquipItem => LobbyEquipmentEndpointsEquipItem::from_value_to_bytes(value),
            AbstractSchema::LobbyEquipmentEndpointsUnequipItem => LobbyEquipmentEndpointsUnequipItem::from_value_to_bytes(value),
            AbstractSchema::LobbyEquipmentEndpointsAddedItemNotification => {
                LobbyEquipmentEndpointsAddedItemNotification::from_value_to_bytes(value)
            }
            AbstractSchema::LobbyEquipmentEndpointsUpdatedItemNotification => {
                LobbyEquipmentEndpointsUpdatedItemNotification::from_value_to_bytes(value)
            }
            AbstractSchema::LobbyHeroesEndpointsEquipHero => LobbyHeroesEndpointsEquipHero::from_value_to_bytes(value),
            AbstractSchema::LobbyHeroesEndpointsGetHeroesList => LobbyHeroesEndpointsGetHeroesList::from_value_to_bytes(value),
            AbstractSchema::LobbyHeroesEndpointsHeroAddedNotification => {
                LobbyHeroesEndpointsHeroAddedNotification::from_value_to_bytes(value)
            }
            AbstractSchema::LobbyLobbyStartGame => LobbyLobbyStartGame::from_value_to_bytes(value),
            AbstractSchema::LobbyRegionsGet => LobbyRegionsGet::from_value_to_bytes(value),
            AbstractSchema::LobbyRegionsSet => LobbyRegionsSet::from_value_to_bytes(value),
            AbstractSchema::LobbySettingsGet => LobbySettingsGet::from_value_to_bytes(value),
            AbstractSchema::LobbySettingsSet => LobbySettingsSet::from_value_to_bytes(value),
            AbstractSchema::LobbyStatsEndpointsGetLevelUpOptionsByPersonalType => {
                LobbyStatsEndpointsGetLevelUpOptionsByPersonalType::from_value_to_bytes(value)
            }
            AbstractSchema::LobbyUserGetUserData => LobbyUserGetUserData::from_value_to_bytes(value),
            AbstractSchema::LobbyUserUpdateUsername => LobbyUserUpdateUsername::from_value_to_bytes(value),
            AbstractSchema::LobbyUserGetLeaderBoard => LobbyUserGetLeaderBoard::from_value_to_bytes(value),
            AbstractSchema::LobbyUserUpdateProfileImage => LobbyUserUpdateProfileImage::from_value_to_bytes(value),
            AbstractSchema::MarketItemsGetLootboxesList => MarketItemsGetLootboxesList::from_value_to_bytes(value),
            AbstractSchema::ProductFactoryLootboxTypeGetByLootboxId => {
                ProductFactoryLootboxTypeGetByLootboxId::from_value_to_bytes(value)
            }
            AbstractSchema::ProductFactoryProductLootboxOpenedNotification => {
                ProductFactoryProductLootboxOpenedNotification::from_value_to_bytes(value)
            }
            AbstractSchema::PromoCodesUseCode => PromoCodesUseCode::from_value_to_bytes(value),
            AbstractSchema::PurchaseBalanceUserBalanceChangedNotification => {
                PurchaseBalanceUserBalanceChangedNotification::from_value_to_bytes(value)
            }
            AbstractSchema::PurchaseProductPurchaseLootbox => PurchaseProductPurchaseLootbox::from_value_to_bytes(value),
            AbstractSchema::PurchaseProductGetHeroList => PurchaseProductGetHeroList::from_value_to_bytes(value),
            AbstractSchema::PurchaseProductGetEquipmentList => PurchaseProductGetEquipmentList::from_value_to_bytes(value),
            AbstractSchema::PurchaseWalletGetByUserId => PurchaseWalletGetByUserId::from_value_to_bytes(value),
            AbstractSchema::PurchaseWalletGetWalletByUserId => PurchaseWalletGetWalletByUserId::from_value_to_bytes(value),
            AbstractSchema::TransactionsBalanceGetBalanceByUserId => TransactionsBalanceGetBalanceByUserId::from_value_to_bytes(value),
            AbstractSchema::TransactionsBalanceGetBalancesByUserId => {
                TransactionsBalanceGetBalancesByUserId::from_value_to_bytes(value)
            }
            AbstractSchema::TransactionsBalanceGetBalancesByUserIdAsArray => {
                TransactionsBalanceGetBalancesByUserIdAsArray::from_value_to_bytes(value)
            }
            AbstractSchema::TransactionsBalanceGetListWithPagination => {
                TransactionsBalanceGetListWithPagination::from_value_to_bytes(value)
            }
            AbstractSchema::UserProfileGetMyProfileForBytes => UserProfileGetMyProfileForBytes::from_value_to_bytes(value),
            AbstractSchema::UserProfileGetTestData => UserProfileGetTestData::from_value_to_bytes(value),
            AbstractSchema::OrchestratorLootboxPurchase => OrchestratorLootboxPurchase::from_value_to_bytes(value),
        }
    }

    pub fn topic_to_send(&self) -> String {
        match self {
            AbstractSchema::AuthAuthLogin => AuthAuthLogin::topic_to_send(),
            AbstractSchema::AuthAuthSendRequestToResetPassword => AuthAuthSendRequestToResetPassword::topic_to_send(),
            AbstractSchema::AuthAuthResetPassword => AuthAuthResetPassword::topic_to_send(),
            AbstractSchema::AuthAuthConfirmPassword => AuthAuthConfirmPassword::topic_to_send(),
            AbstractSchema::AuthAuthCreateRequestToConfirmEmail => AuthAuthCreateRequestToConfirmEmail::topic_to_send(),
            AbstractSchema::AuthAuthConfirmEmailByCode => AuthAuthConfirmEmailByCode::topic_to_send(),
            AbstractSchema::AuthAuthDeleteEmailRequest => AuthAuthDeleteEmailRequest::topic_to_send(),
            AbstractSchema::AuthAuthSetPassword => AuthAuthSetPassword::topic_to_send(),
            AbstractSchema::AuthAuthResentConfirmationMail => AuthAuthResentConfirmationMail::topic_to_send(),
            AbstractSchema::AuthAuthLogout => AuthAuthLogout::topic_to_send(),
            AbstractSchema::AuthAuthEmptyMethod => AuthAuthEmptyMethod::topic_to_send(),
            AbstractSchema::AuthAuthAssignProviderAccountToDeviceId => AuthAuthAssignProviderAccountToDeviceId::topic_to_send(),
            AbstractSchema::BalancesBalancesGetSoftCurrencyBalance => BalancesBalancesGetSoftCurrencyBalance::topic_to_send(),
            AbstractSchema::BalancesBalancesIncreaseSoftCurrency => BalancesBalancesIncreaseSoftCurrency::topic_to_send(),
            AbstractSchema::BalancesBalancesDecreaseSoftCurrency => BalancesBalancesDecreaseSoftCurrency::topic_to_send(),
            AbstractSchema::BalancesBalancesAddFreeExperience => BalancesBalancesAddFreeExperience::topic_to_send(),
            AbstractSchema::BalancesBalancesUseFreeExperience => BalancesBalancesUseFreeExperience::topic_to_send(),
            AbstractSchema::BalancesBalancesGetBalancesByUserId => BalancesBalancesGetBalancesByUserId::topic_to_send(),
            AbstractSchema::BalancesBalancesGetFreeExperienceBalance => BalancesBalancesGetFreeExperienceBalance::topic_to_send(),
            AbstractSchema::BalancesBalancesFreeExperienceAddedNotification => {
                BalancesBalancesFreeExperienceAddedNotification::topic_to_send()
            }
            AbstractSchema::GameBalancerGameBalancerStopSearching => GameBalancerGameBalancerStopSearching::topic_to_send(),
            AbstractSchema::GameBalancerGameBalancerGameStartedNotification => {
                GameBalancerGameBalancerGameStartedNotification::topic_to_send()
            }
            AbstractSchema::GameBalancerGameBalancerCheckInNotification => {
                GameBalancerGameBalancerCheckInNotification::topic_to_send()
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsStatsUpdatedNotification => {
                ListeriaStorageHeroesEndpointsStatsUpdatedNotification::topic_to_send()
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsGetHeroesListByUserId => {
                ListeriaStorageHeroesEndpointsGetHeroesListByUserId::topic_to_send()
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero => {
                ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero::topic_to_send()
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsHeroAddedNotification => {
                ListeriaStorageHeroesEndpointsHeroAddedNotification::topic_to_send()
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsLevelUp => ListeriaStorageHeroesEndpointsLevelUp::topic_to_send(),
            AbstractSchema::ListeriaStorageInventoryEndpointsGetLootboxesList => {
                ListeriaStorageInventoryEndpointsGetLootboxesList::topic_to_send()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsOpenLootbox => {
                ListeriaStorageInventoryEndpointsOpenLootbox::topic_to_send()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetItemsList => {
                ListeriaStorageInventoryEndpointsGetItemsList::topic_to_send()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetHeroScrollsCount => {
                ListeriaStorageInventoryEndpointsGetHeroScrollsCount::topic_to_send()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount => {
                ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount::topic_to_send()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification => {
                ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification::topic_to_send()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsLevelUp => ListeriaStorageInventoryEndpointsLevelUp::topic_to_send(),
            AbstractSchema::LobbyEquipmentEndpointsEquipItem => LobbyEquipmentEndpointsEquipItem::topic_to_send(),
            AbstractSchema::LobbyEquipmentEndpointsUnequipItem => LobbyEquipmentEndpointsUnequipItem::topic_to_send(),
            AbstractSchema::LobbyEquipmentEndpointsAddedItemNotification => {
                LobbyEquipmentEndpointsAddedItemNotification::topic_to_send()
            }
            AbstractSchema::LobbyEquipmentEndpointsUpdatedItemNotification => {
                LobbyEquipmentEndpointsUpdatedItemNotification::topic_to_send()
            }
            AbstractSchema::LobbyHeroesEndpointsEquipHero => LobbyHeroesEndpointsEquipHero::topic_to_send(),
            AbstractSchema::LobbyHeroesEndpointsGetHeroesList => LobbyHeroesEndpointsGetHeroesList::topic_to_send(),
            AbstractSchema::LobbyHeroesEndpointsHeroAddedNotification => LobbyHeroesEndpointsHeroAddedNotification::topic_to_send(),
            AbstractSchema::LobbyLobbyStartGame => LobbyLobbyStartGame::topic_to_send(),
            AbstractSchema::LobbyRegionsGet => LobbyRegionsGet::topic_to_send(),
            AbstractSchema::LobbyRegionsSet => LobbyRegionsSet::topic_to_send(),
            AbstractSchema::LobbySettingsGet => LobbySettingsGet::topic_to_send(),
            AbstractSchema::LobbySettingsSet => LobbySettingsSet::topic_to_send(),
            AbstractSchema::LobbyStatsEndpointsGetLevelUpOptionsByPersonalType => {
                LobbyStatsEndpointsGetLevelUpOptionsByPersonalType::topic_to_send()
            }
            AbstractSchema::LobbyUserGetUserData => LobbyUserGetUserData::topic_to_send(),
            AbstractSchema::LobbyUserUpdateUsername => LobbyUserUpdateUsername::topic_to_send(),
            AbstractSchema::LobbyUserGetLeaderBoard => LobbyUserGetLeaderBoard::topic_to_send(),
            AbstractSchema::LobbyUserUpdateProfileImage => LobbyUserUpdateProfileImage::topic_to_send(),
            AbstractSchema::MarketItemsGetLootboxesList => MarketItemsGetLootboxesList::topic_to_send(),
            AbstractSchema::ProductFactoryLootboxTypeGetByLootboxId => ProductFactoryLootboxTypeGetByLootboxId::topic_to_send(),
            AbstractSchema::ProductFactoryProductLootboxOpenedNotification => {
                ProductFactoryProductLootboxOpenedNotification::topic_to_send()
            }
            AbstractSchema::PromoCodesUseCode => PromoCodesUseCode::topic_to_send(),
            AbstractSchema::PurchaseBalanceUserBalanceChangedNotification => {
                PurchaseBalanceUserBalanceChangedNotification::topic_to_send()
            }
            AbstractSchema::PurchaseProductPurchaseLootbox => PurchaseProductPurchaseLootbox::topic_to_send(),
            AbstractSchema::PurchaseProductGetHeroList => PurchaseProductGetHeroList::topic_to_send(),
            AbstractSchema::PurchaseProductGetEquipmentList => PurchaseProductGetEquipmentList::topic_to_send(),
            AbstractSchema::PurchaseWalletGetByUserId => PurchaseWalletGetByUserId::topic_to_send(),
            AbstractSchema::PurchaseWalletGetWalletByUserId => PurchaseWalletGetWalletByUserId::topic_to_send(),
            AbstractSchema::TransactionsBalanceGetBalanceByUserId => TransactionsBalanceGetBalanceByUserId::topic_to_send(),
            AbstractSchema::TransactionsBalanceGetBalancesByUserId => TransactionsBalanceGetBalancesByUserId::topic_to_send(),
            AbstractSchema::TransactionsBalanceGetBalancesByUserIdAsArray => {
                TransactionsBalanceGetBalancesByUserIdAsArray::topic_to_send()
            }
            AbstractSchema::TransactionsBalanceGetListWithPagination => TransactionsBalanceGetListWithPagination::topic_to_send(),
            AbstractSchema::UserProfileGetMyProfileForBytes => UserProfileGetMyProfileForBytes::topic_to_send(),
            AbstractSchema::UserProfileGetTestData => UserProfileGetTestData::topic_to_send(),
            AbstractSchema::OrchestratorLootboxPurchase => OrchestratorLootboxPurchase::topic_to_send(),
        }
    }

    pub fn topic_to_response(&self) -> String {
        match self {
            AbstractSchema::AuthAuthLogin => AuthAuthLogin::topic_to_response(),
            AbstractSchema::AuthAuthSendRequestToResetPassword => AuthAuthSendRequestToResetPassword::topic_to_response(),
            AbstractSchema::AuthAuthResetPassword => AuthAuthResetPassword::topic_to_response(),
            AbstractSchema::AuthAuthConfirmPassword => AuthAuthConfirmPassword::topic_to_response(),
            AbstractSchema::AuthAuthCreateRequestToConfirmEmail => AuthAuthCreateRequestToConfirmEmail::topic_to_response(),
            AbstractSchema::AuthAuthConfirmEmailByCode => AuthAuthConfirmEmailByCode::topic_to_response(),
            AbstractSchema::AuthAuthDeleteEmailRequest => AuthAuthDeleteEmailRequest::topic_to_response(),
            AbstractSchema::AuthAuthSetPassword => AuthAuthSetPassword::topic_to_response(),
            AbstractSchema::AuthAuthResentConfirmationMail => AuthAuthResentConfirmationMail::topic_to_response(),
            AbstractSchema::AuthAuthLogout => AuthAuthLogout::topic_to_response(),
            AbstractSchema::AuthAuthEmptyMethod => AuthAuthEmptyMethod::topic_to_response(),
            AbstractSchema::AuthAuthAssignProviderAccountToDeviceId => AuthAuthAssignProviderAccountToDeviceId::topic_to_response(),
            AbstractSchema::BalancesBalancesGetSoftCurrencyBalance => BalancesBalancesGetSoftCurrencyBalance::topic_to_response(),
            AbstractSchema::BalancesBalancesIncreaseSoftCurrency => BalancesBalancesIncreaseSoftCurrency::topic_to_response(),
            AbstractSchema::BalancesBalancesDecreaseSoftCurrency => BalancesBalancesDecreaseSoftCurrency::topic_to_response(),
            AbstractSchema::BalancesBalancesAddFreeExperience => BalancesBalancesAddFreeExperience::topic_to_response(),
            AbstractSchema::BalancesBalancesUseFreeExperience => BalancesBalancesUseFreeExperience::topic_to_response(),
            AbstractSchema::BalancesBalancesGetBalancesByUserId => BalancesBalancesGetBalancesByUserId::topic_to_response(),
            AbstractSchema::BalancesBalancesGetFreeExperienceBalance => BalancesBalancesGetFreeExperienceBalance::topic_to_response(),
            AbstractSchema::BalancesBalancesFreeExperienceAddedNotification => {
                BalancesBalancesFreeExperienceAddedNotification::topic_to_response()
            }
            AbstractSchema::GameBalancerGameBalancerStopSearching => GameBalancerGameBalancerStopSearching::topic_to_response(),
            AbstractSchema::GameBalancerGameBalancerGameStartedNotification => {
                GameBalancerGameBalancerGameStartedNotification::topic_to_response()
            }
            AbstractSchema::GameBalancerGameBalancerCheckInNotification => {
                GameBalancerGameBalancerCheckInNotification::topic_to_response()
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsStatsUpdatedNotification => {
                ListeriaStorageHeroesEndpointsStatsUpdatedNotification::topic_to_response()
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsGetHeroesListByUserId => {
                ListeriaStorageHeroesEndpointsGetHeroesListByUserId::topic_to_response()
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero => {
                ListeriaStorageHeroesEndpointsGiveFreeExperienceToHero::topic_to_response()
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsHeroAddedNotification => {
                ListeriaStorageHeroesEndpointsHeroAddedNotification::topic_to_response()
            }
            AbstractSchema::ListeriaStorageHeroesEndpointsLevelUp => ListeriaStorageHeroesEndpointsLevelUp::topic_to_response(),
            AbstractSchema::ListeriaStorageInventoryEndpointsGetLootboxesList => {
                ListeriaStorageInventoryEndpointsGetLootboxesList::topic_to_response()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsOpenLootbox => {
                ListeriaStorageInventoryEndpointsOpenLootbox::topic_to_response()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetItemsList => {
                ListeriaStorageInventoryEndpointsGetItemsList::topic_to_response()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetHeroScrollsCount => {
                ListeriaStorageInventoryEndpointsGetHeroScrollsCount::topic_to_response()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount => {
                ListeriaStorageInventoryEndpointsGetEquipmentScrollsCount::topic_to_response()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification => {
                ListeriaStorageInventoryEndpointsAddedUnequippableItemNotification::topic_to_response()
            }
            AbstractSchema::ListeriaStorageInventoryEndpointsLevelUp => ListeriaStorageInventoryEndpointsLevelUp::topic_to_response(),
            AbstractSchema::LobbyEquipmentEndpointsEquipItem => LobbyEquipmentEndpointsEquipItem::topic_to_response(),
            AbstractSchema::LobbyEquipmentEndpointsUnequipItem => LobbyEquipmentEndpointsUnequipItem::topic_to_response(),
            AbstractSchema::LobbyEquipmentEndpointsAddedItemNotification => {
                LobbyEquipmentEndpointsAddedItemNotification::topic_to_response()
            }
            AbstractSchema::LobbyEquipmentEndpointsUpdatedItemNotification => {
                LobbyEquipmentEndpointsUpdatedItemNotification::topic_to_response()
            }
            AbstractSchema::LobbyHeroesEndpointsEquipHero => LobbyHeroesEndpointsEquipHero::topic_to_response(),
            AbstractSchema::LobbyHeroesEndpointsGetHeroesList => LobbyHeroesEndpointsGetHeroesList::topic_to_response(),
            AbstractSchema::LobbyHeroesEndpointsHeroAddedNotification => {
                LobbyHeroesEndpointsHeroAddedNotification::topic_to_response()
            }
            AbstractSchema::LobbyLobbyStartGame => LobbyLobbyStartGame::topic_to_response(),
            AbstractSchema::LobbyRegionsGet => LobbyRegionsGet::topic_to_response(),
            AbstractSchema::LobbyRegionsSet => LobbyRegionsSet::topic_to_response(),
            AbstractSchema::LobbySettingsGet => LobbySettingsGet::topic_to_response(),
            AbstractSchema::LobbySettingsSet => LobbySettingsSet::topic_to_response(),
            AbstractSchema::LobbyStatsEndpointsGetLevelUpOptionsByPersonalType => {
                LobbyStatsEndpointsGetLevelUpOptionsByPersonalType::topic_to_response()
            }
            AbstractSchema::LobbyUserGetUserData => LobbyUserGetUserData::topic_to_response(),
            AbstractSchema::LobbyUserUpdateUsername => LobbyUserUpdateUsername::topic_to_response(),
            AbstractSchema::LobbyUserGetLeaderBoard => LobbyUserGetLeaderBoard::topic_to_response(),
            AbstractSchema::LobbyUserUpdateProfileImage => LobbyUserUpdateProfileImage::topic_to_response(),
            AbstractSchema::MarketItemsGetLootboxesList => MarketItemsGetLootboxesList::topic_to_response(),
            AbstractSchema::ProductFactoryLootboxTypeGetByLootboxId => ProductFactoryLootboxTypeGetByLootboxId::topic_to_response(),
            AbstractSchema::ProductFactoryProductLootboxOpenedNotification => {
                ProductFactoryProductLootboxOpenedNotification::topic_to_response()
            }
            AbstractSchema::PromoCodesUseCode => PromoCodesUseCode::topic_to_response(),
            AbstractSchema::PurchaseBalanceUserBalanceChangedNotification => {
                PurchaseBalanceUserBalanceChangedNotification::topic_to_response()
            }
            AbstractSchema::PurchaseProductPurchaseLootbox => PurchaseProductPurchaseLootbox::topic_to_response(),
            AbstractSchema::PurchaseProductGetHeroList => PurchaseProductGetHeroList::topic_to_response(),
            AbstractSchema::PurchaseProductGetEquipmentList => PurchaseProductGetEquipmentList::topic_to_response(),
            AbstractSchema::PurchaseWalletGetByUserId => PurchaseWalletGetByUserId::topic_to_response(),
            AbstractSchema::PurchaseWalletGetWalletByUserId => PurchaseWalletGetWalletByUserId::topic_to_response(),
            AbstractSchema::TransactionsBalanceGetBalanceByUserId => TransactionsBalanceGetBalanceByUserId::topic_to_response(),
            AbstractSchema::TransactionsBalanceGetBalancesByUserId => TransactionsBalanceGetBalancesByUserId::topic_to_response(),
            AbstractSchema::TransactionsBalanceGetBalancesByUserIdAsArray => {
                TransactionsBalanceGetBalancesByUserIdAsArray::topic_to_response()
            }
            AbstractSchema::TransactionsBalanceGetListWithPagination => TransactionsBalanceGetListWithPagination::topic_to_response(),
            AbstractSchema::UserProfileGetMyProfileForBytes => UserProfileGetMyProfileForBytes::topic_to_response(),
            AbstractSchema::UserProfileGetTestData => UserProfileGetTestData::topic_to_response(),
            AbstractSchema::OrchestratorLootboxPurchase => OrchestratorLootboxPurchase::topic_to_response(),
        }
    }
}
