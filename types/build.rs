#[cfg(feature = "rebuild")]
pub mod parser;

fn main() {
    #[cfg(feature = "rebuild")]
    build::build_schemas();
}

#[cfg(feature = "rebuild")]
mod build {
    use crate::parser::{
        schema::Schema,
        schemas_generator::SchemasGenerator,
        schemas_loader::{LoaderGit, LoaderJson, SchemaLoader},
    };
    use config::env::EnvLoaded;
    use quote::{quote, ToTokens};
    use std::{ops::Add, path::PathBuf};

    pub fn build_schemas() {
        let loader_type = String::load(Some(String::from("LOADERTYPE"))).unwrap();

        let schemas = match loader_type.as_str() {
            "git" => SchemaLoader::new(LoaderGit::default()).load().unwrap(),
            "file" => {
                let path = String::load(Some(String::from("FILEPATH"))).unwrap();
                SchemaLoader::new(LoaderJson::new(&path)).load().unwrap()
            }
            _ => panic!("Unknown loader type"),
        };

        generate_schemas(schemas.clone(), "./src/rust_byte_api_gateway", "full_schemas.rs");
    }

    fn generate_schemas(schemas: Vec<Schema>, path: &str, filename: &str) {
        // TODO: Check this
        let header = "#![allow(unknown_lints)]\n#![allow(clippy::all)]\n
        /// This file are autogenerated on build, everything you write here will be replaced";

        let scmas_names: Vec<String> = schemas.clone().into_iter().map(|schema| schema.create_name()).collect();

        let json = serde_json::to_value(scmas_names).unwrap();

        std::fs::write(format!("{}/schema_names.json", path), json.to_string());

        let schema_generator = SchemasGenerator { schemas };

        let code = schema_generator.into_token_stream();

        let out = &mut PathBuf::from(path);
        out.push(filename);

        let content = format!("{}\n\n{}", header, code.to_string());

        std::fs::write(out, content).unwrap();
    }

    fn generate_nats_receivers_runner(schemas: Vec<Schema>, path: &str, filename: &str) {
        let header = "// This file are autogenerated on build, everything you write here will be replaced";
        let receivers = schemas
            .into_iter()
            .map(|schema| schema.create_ident())
            .map(|ident| {
                quote! {
                    let nats_response_receiver = NatsResponseReceiver::new(
                        nats.clone(),
                        sender.clone(),
                        health_checker.clone()
                    );
                    tokio::spawn(nats_response_receiver.run::<#ident>());
                }
            })
            .collect::<Vec<_>>();

        let code = quote! {
            #[allow(clippy::all)]
            use crate::nats::response_receiver::NatsResponseReceiver;
            use crate::generated::full_schemas::*;
            use crate::common::events::SendEvent;
            use tokio::sync::broadcast::Sender;
            use healthchecker::HealthChecker;
            use transport::nats::Nats;

            pub async fn run_nats_receivers(
                nats: Nats,
                sender: Sender<SendEvent<Vec<u8>>>,
                health_checker: HealthChecker
            ) {
                #(#receivers)*
            }
        };

        let out = &mut PathBuf::from(path);
        out.push(filename);
        let content = format!("{}\n\n{}", header, code.to_string());
        std::fs::write(out, content).unwrap();
    }
}
