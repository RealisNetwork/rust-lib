#[cfg(feature = "rebuild")]
pub mod parser;

fn main() {
    #[cfg(feature = "rebuild")]
    build::build_schemas();
}

#[cfg(feature = "rebuild")]
mod build {
    use crate::parser::{
        schema::Schema,
        schemas_generator::SchemasGenerator,
        schemas_loader::{LoaderGit, LoaderJson, SchemaLoader},
    };
    use config::env::EnvLoaded;
    use quote::{quote, ToTokens};
    use std::{ops::Add, path::PathBuf};

    pub fn build_schemas() {
        let loader_type = String::load(Some(String::from("LOADERTYPE"))).unwrap();

        let schemas = match loader_type.as_str() {
            "git" => SchemaLoader::new(LoaderGit::default()).load().unwrap(),
            "file" => {
                let path = String::load(Some(String::from("FILEPATH"))).unwrap();
                SchemaLoader::new(LoaderJson::new(&path)).load().unwrap()
            }
            _ => panic!("Unknown loader type"),
        };

        generate_schemas(schemas.clone(), "./src/rust_byte_api_gateway", "full_schemas.rs");
    }

    fn generate_schemas(schemas: Vec<Schema>, path: &str, filename: &str) {
        // TODO: Check this
        let header = "#![allow(unknown_lints)]\n#![allow(clippy::all)]\n
        // This file are autogenerated on build, everything you write here will be replaced";

        let scmas_names: Vec<String> = schemas.clone().into_iter().map(|schema| schema.create_name()).collect();

        let json = serde_json::to_value(scmas_names).unwrap();

        std::fs::write(format!("{}/schema_names.json", path), json.to_string());

        let schema_generator = SchemasGenerator { schemas };

        let code = schema_generator.into_token_stream();

        let out = &mut PathBuf::from(path);
        out.push(filename);

        let content = format!("{}\n\n{}", header, code.to_string());

        std::fs::write(out, content).unwrap();
    }
}
