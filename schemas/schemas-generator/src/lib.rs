pub mod agent;
pub mod agent_params;
pub mod env_loader;
pub mod schema_declaration;
pub mod types;

use crate::agent::Agent;
use crate::env_loader::{GitLoader, Loader};
use ::config::env::EnvLoaded;
use quote::__private::Ident;
use quote::{quote, ToTokens};
use std::collections::HashSet;
use std::io::Write;
use std::path::{Path, PathBuf};
use syn::__private::Span;

const PATH: &str = "./schemas/src/generated_schemas/";
const MOD_RS: &str = "mod.rs";

fn main() {
    let git_loader = GitLoader::load(None).expect("Fail to load env");
    println!("{:?}", git_loader);

    let agents: Vec<Agent> = git_loader.start().expect("Fail to load from Git");

    println!("{:#?}", agents.first());

    // TODO: Check this
    let header =
        "// This file are autogenerated on build, everything you write here will be replaced";

    for agent in agents
        .clone()
        .into_iter()
        .map(|agent| agent.create_directory_name())
        .collect::<HashSet<_>>()
    {
        // Creating directories
        std::fs::create_dir_all(format!("{}{}", PATH, agent)).expect("Fail to create directory");
        // Creating mod.rs in each directory
        let mut mod_file =
            std::fs::File::create(&Path::new(&format!("{}{}/{}", PATH, agent, MOD_RS)))
                .expect("Fail to create \"mod.rs\" file");
        // Creating `pub mod ...`
        let agent_methods = agents
            .iter()
            .filter(|a| a.create_directory_name() == agent)
            .map(|agent| Ident::new(&agent.create_file_name(), Span::call_site()))
            .collect::<Vec<_>>();
        let pub_mods = quote! {
          #( pub mod #agent_methods; )*
        };
        println!("{:?}", agent_methods);
        mod_file
            .write(pub_mods.to_string().as_bytes())
            .expect("Fail to write to \"mod.rs\"");

        // Creating `pub use ...::*
        // Maybe get rid of this?
        let agent_methods = agents
            .iter()
            .filter(|a| a.agent == agent)
            .map(|agent| Ident::new(&agent.create_file_name(), Span::call_site()))
            .collect::<Vec<_>>();
        let pub_mods = quote! {
          #( pub use #agent_methods::*; )*
        };
        mod_file
            .write(pub_mods.to_string().as_bytes())
            .expect("Fail to write to \"mod.rs\"");
    }

    // Creating mod.rs in generated schemas
    let mut mod_file = std::fs::File::create(&Path::new(&format!("{}{}", PATH, MOD_RS)))
        .expect("Fail to create \"mod.rs\" file");
    let values = agents
        .clone()
        .into_iter()
        .map(|agent| agent.create_directory_name())
        .collect::<HashSet<_>>()
        .into_iter()
        .map(|agent| Ident::new(&agent, Span::call_site()));

    let pub_mod = quote! {
      #( pub mod #values; )*
    };
    mod_file
        .write(pub_mod.to_string().as_bytes())
        .expect("Fail to write to \"mod.rs\"");

    for schema in agents {
        let agent = schema.create_directory_name();
        let method = schema.create_file_name();

        let code = schema.into_token_stream();

        let out = &mut PathBuf::from(format!("{}{}", PATH, agent));
        out.push(format!("{}.rs", method));
        let content = format!("{}\n\n{}", header, code.to_string());

        std::fs::write(out, content).unwrap();
    }
}

#[cfg(test)]
pub mod tests {
    use crate::env_loader::GitLoader;
    use crate::{get_file, Agent};
    use serde_json::{json, Value};

    #[test]
    fn get_json() {
        let filename = "all_schemas.rs";

        let json = json!({
          "agent": "user",
          "method": "profile_getMyProfileForBytes",
          "params": {},
          "returns": {
            "type": "object",
            "properties": {
              "id": {
                "minimum": -2147483648,
                "maximum": 2147483647,
                "additionalAttributes": {
                  "numberType": "int"
                },
                "type": "integer"
              },
              "userId": {
                "type": "string"
              },
              "nickname": {
                "type": "string"
              },
              "email": {
                "type": "string"
              },
              "verified": {
                "type": "boolean"
              },
              "isNicknameChanged": {
                "type": "boolean"
              },
              "isSubscribedToMailing": {
                "type": "boolean"
              },
              "suspicious": {
                "type": "boolean"
              },
              "isConfirmed": {
                "type": "boolean"
              },
              "notice": {
                "type": "string"
              },
              "isBanned": {
                "type": "boolean"
              },
              "isDeleted": {
                "type": "boolean"
              },
              "reason": {
                "type": "string"
              },
              "registeredAt": {
                "type": "string"
              }
            },
            "required": [
              "id",
              "userId",
              "nickname",
              "email",
              "verified",
              "isNicknameChanged",
              "isSubscribedToMailing",
              "suspicious",
              "isConfirmed",
              "notice",
              "isBanned",
              "isDeleted",
              "reason",
              "registeredAt"
            ]
          },
          "topic": "user_profile_getMyProfileForBytes"
        });

        let schema: Agent = serde_json::from_value(json).expect("Fail to parse json");
        println!("{:#?}", schema);

        let name = schema.agent;

        std::fs::write(format!("{}/schema_names.json", name), json.to_string()).unwrap();

        let schema_generator = AgentsGenerator { schema };

        let code = schema_generator.into_token_stream();

        let out = &mut PathBuf::from(path);
        out.push(filename);

        let content = format!("{}\n\n{}", header, code.to_string());

        std::fs::write(out, content).map(|_| ());
    }
}
